<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Sleeping Wombat GUI: rttr::type Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Sleeping Wombat GUI
   &#160;<span id="projectnumber">0.100</span>
   </div>
   <div id="projectbrief">swGUI</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerttr.html">rttr</a></li><li class="navelem"><a class="el" href="classrttr_1_1type.html">type</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classrttr_1_1type-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rttr::type Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="type_8h_source.html">type.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa51c17659f86333038379c23b03d2db0"><td class="memItemLeft" align="right" valign="top">typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aa51c17659f86333038379c23b03d2db0">type_id</a></td></tr>
<tr class="separator:aa51c17659f86333038379c23b03d2db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aca76e402ae8dc21e8489cf190960b738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aca76e402ae8dc21e8489cf190960b738">type</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:aca76e402ae8dc21e8489cf190960b738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a type to another one.  <a href="#aca76e402ae8dc21e8489cf190960b738">More...</a><br /></td></tr>
<tr class="separator:aca76e402ae8dc21e8489cf190960b738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9497adb19711d1797d952d5e3525178"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ac9497adb19711d1797d952d5e3525178">operator=</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac9497adb19711d1797d952d5e3525178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a type to another one.  <a href="#ac9497adb19711d1797d952d5e3525178">More...</a><br /></td></tr>
<tr class="separator:ac9497adb19711d1797d952d5e3525178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8e40d92359f0ad2b154e91eefbf070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a9f8e40d92359f0ad2b154e91eefbf070">operator&lt;</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9f8e40d92359f0ad2b154e91eefbf070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator for sorting the type data according to some internal criterion.  <a href="#a9f8e40d92359f0ad2b154e91eefbf070">More...</a><br /></td></tr>
<tr class="separator:a9f8e40d92359f0ad2b154e91eefbf070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb2b7d6d55de3f031d24b5f5b9a2682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a9fb2b7d6d55de3f031d24b5f5b9a2682">operator&gt;</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9fb2b7d6d55de3f031d24b5f5b9a2682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator for sorting the type data according to some internal criterion.  <a href="#a9fb2b7d6d55de3f031d24b5f5b9a2682">More...</a><br /></td></tr>
<tr class="separator:a9fb2b7d6d55de3f031d24b5f5b9a2682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4cad0b952ccee31ebc1b95f992377c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aad4cad0b952ccee31ebc1b95f992377c">operator&gt;=</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:aad4cad0b952ccee31ebc1b95f992377c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator for sorting the type data according to some internal criterion.  <a href="#aad4cad0b952ccee31ebc1b95f992377c">More...</a><br /></td></tr>
<tr class="separator:aad4cad0b952ccee31ebc1b95f992377c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca10de112732755cf059b80c65a1139"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#abca10de112732755cf059b80c65a1139">operator&lt;=</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:abca10de112732755cf059b80c65a1139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator for sorting the type data according to some internal criterion.  <a href="#abca10de112732755cf059b80c65a1139">More...</a><br /></td></tr>
<tr class="separator:abca10de112732755cf059b80c65a1139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c23c5509bb1230308a36be013f4cc13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a6c23c5509bb1230308a36be013f4cc13">operator==</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6c23c5509bb1230308a36be013f4cc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this type with the <em>other</em> type and returns true if both describe the same type, otherwise returns false.  <a href="#a6c23c5509bb1230308a36be013f4cc13">More...</a><br /></td></tr>
<tr class="separator:a6c23c5509bb1230308a36be013f4cc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f547bdd0a3202d470b9a93e03568d69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a1f547bdd0a3202d470b9a93e03568d69">operator!=</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1f547bdd0a3202d470b9a93e03568d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this type with the <em>other</em> type and returns true if both describe different types, otherwise returns false.  <a href="#a1f547bdd0a3202d470b9a93e03568d69">More...</a><br /></td></tr>
<tr class="separator:a1f547bdd0a3202d470b9a93e03568d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1ca9b4cfd1b1843b3e591e1fc9de93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1type.html#aa51c17659f86333038379c23b03d2db0">type_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aed1ca9b4cfd1b1843b3e591e1fc9de93">get_id</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:aed1ca9b4cfd1b1843b3e591e1fc9de93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the id of this type.  <a href="#aed1ca9b4cfd1b1843b3e591e1fc9de93">More...</a><br /></td></tr>
<tr class="separator:aed1ca9b4cfd1b1843b3e591e1fc9de93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83515d71a2de9a15e22eb43409720e78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> <a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a83515d71a2de9a15e22eb43409720e78">get_name</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a83515d71a2de9a15e22eb43409720e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unique and human-readable name of the type.  <a href="#a83515d71a2de9a15e22eb43409720e78">More...</a><br /></td></tr>
<tr class="separator:a83515d71a2de9a15e22eb43409720e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369fe02e20b9b98cf22371a55be9ad14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a369fe02e20b9b98cf22371a55be9ad14">is_valid</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a369fe02e20b9b98cf22371a55be9ad14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this type is valid, that means the type holds valid data to a type.  <a href="#a369fe02e20b9b98cf22371a55be9ad14">More...</a><br /></td></tr>
<tr class="separator:a369fe02e20b9b98cf22371a55be9ad14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418976934476eb377fe83fd95138a283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a418976934476eb377fe83fd95138a283">operator bool</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a418976934476eb377fe83fd95138a283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to check if this <a class="el" href="classrttr_1_1type.html">type</a> is valid or not.  <a href="#a418976934476eb377fe83fd95138a283">More...</a><br /></td></tr>
<tr class="separator:a418976934476eb377fe83fd95138a283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d1f7ba7a387ec15c814963b5b2f7a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> <a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ab7d1f7ba7a387ec15c814963b5b2f7a4">get_raw_type</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab7d1f7ba7a387ec15c814963b5b2f7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type object which represent the raw type. A raw type, is a type type without any qualifiers (const and volatile) nor any pointer.  <a href="#ab7d1f7ba7a387ec15c814963b5b2f7a4">More...</a><br /></td></tr>
<tr class="separator:ab7d1f7ba7a387ec15c814963b5b2f7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead861cbf03c3c0c053bcab465df6f17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> <a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aead861cbf03c3c0c053bcab465df6f17">get_wrapped_type</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:aead861cbf03c3c0c053bcab465df6f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type object which represent the wrapped type. A wrapper type is a class which encapsulate an instance of another type. This encapsulate type is also called <em>wrapped type</em>.  <a href="#aead861cbf03c3c0c053bcab465df6f17">More...</a><br /></td></tr>
<tr class="separator:aead861cbf03c3c0c053bcab465df6f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45f49302f0147f58c15c70f026b0b1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#af45f49302f0147f58c15c70f026b0b1d">get_sizeof</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:af45f49302f0147f58c15c70f026b0b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of the object representation of the current type (i.e. <code>sizeof(T)</code>).  <a href="#af45f49302f0147f58c15c70f026b0b1d">More...</a><br /></td></tr>
<tr class="separator:af45f49302f0147f58c15c70f026b0b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c569e3f047cd10996486ae4259db20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a59c569e3f047cd10996486ae4259db20">is_class</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a59c569e3f047cd10996486ae4259db20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type is class; that is not an atomic type or a method.  <a href="#a59c569e3f047cd10996486ae4259db20">More...</a><br /></td></tr>
<tr class="separator:a59c569e3f047cd10996486ae4259db20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b43b346aec24514269d9cd2d76ddd7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a0b43b346aec24514269d9cd2d76ddd7d">is_enumeration</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0b43b346aec24514269d9cd2d76ddd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents an enumeration.  <a href="#a0b43b346aec24514269d9cd2d76ddd7d">More...</a><br /></td></tr>
<tr class="separator:a0b43b346aec24514269d9cd2d76ddd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91717a96f558d7f3399addd1890c2c8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1enumeration.html">enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a91717a96f558d7f3399addd1890c2c8a">get_enumeration</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a91717a96f558d7f3399addd1890c2c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the enumerator if this type is an enum type; otherwise the returned value is <a class="el" href="classrttr_1_1enumeration.html#aa7cb3e8546e71aa7b21595df49dce48c">not valid</a>.  <a href="#a91717a96f558d7f3399addd1890c2c8a">More...</a><br /></td></tr>
<tr class="separator:a91717a96f558d7f3399addd1890c2c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67382543ad029b45c8f8b1fb24bcd18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#af67382543ad029b45c8f8b1fb24bcd18">is_wrapper</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:af67382543ad029b45c8f8b1fb24bcd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents a wrapper type. A wrapper type is a class which encapsulate an instance of another type. RTTR recognize automatically following wrapper types:  <a href="#af67382543ad029b45c8f8b1fb24bcd18">More...</a><br /></td></tr>
<tr class="separator:af67382543ad029b45c8f8b1fb24bcd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5b74552ed9f7f5fa9b716355262b98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aea5b74552ed9f7f5fa9b716355262b98">is_array</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:aea5b74552ed9f7f5fa9b716355262b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents an array.  <a href="#aea5b74552ed9f7f5fa9b716355262b98">More...</a><br /></td></tr>
<tr class="separator:aea5b74552ed9f7f5fa9b716355262b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccddc8b9dc57dffc657ea117b806212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#adccddc8b9dc57dffc657ea117b806212">is_pointer</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:adccddc8b9dc57dffc657ea117b806212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents a pointer. e.g. <code>int*</code>, or <code>bool*</code>  <a href="#adccddc8b9dc57dffc657ea117b806212">More...</a><br /></td></tr>
<tr class="separator:adccddc8b9dc57dffc657ea117b806212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afafd8c51e787e059f77c96287c70f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a4afafd8c51e787e059f77c96287c70f6">is_arithmetic</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4afafd8c51e787e059f77c96287c70f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents an arithmetic type. An arithmetic type is a integral type or a floating point type. e.g. <code>bool</code>, <code>int</code>, <code>float</code>, etc...  <a href="#a4afafd8c51e787e059f77c96287c70f6">More...</a><br /></td></tr>
<tr class="separator:a4afafd8c51e787e059f77c96287c70f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a861dee09afdf1f5b287a1cb5e6e16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a55a861dee09afdf1f5b287a1cb5e6e16">is_function_pointer</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a55a861dee09afdf1f5b287a1cb5e6e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents a pointer to a function e.g. <code>void (*)(void)</code>  <a href="#a55a861dee09afdf1f5b287a1cb5e6e16">More...</a><br /></td></tr>
<tr class="separator:a55a861dee09afdf1f5b287a1cb5e6e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccb112222ce1d9d3e89c781e358ee5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a6ccb112222ce1d9d3e89c781e358ee5a">is_member_object_pointer</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6ccb112222ce1d9d3e89c781e358ee5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents a pointer to a member object. e.g. <code>int (MyClass::*)</code>  <a href="#a6ccb112222ce1d9d3e89c781e358ee5a">More...</a><br /></td></tr>
<tr class="separator:a6ccb112222ce1d9d3e89c781e358ee5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134e011a3820e329e6ee06da3f879eeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a134e011a3820e329e6ee06da3f879eeb">is_member_function_pointer</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a134e011a3820e329e6ee06da3f879eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents a pointer to a member function. e.g. <code>void (MyClass::*)(void)</code>  <a href="#a134e011a3820e329e6ee06da3f879eeb">More...</a><br /></td></tr>
<tr class="separator:a134e011a3820e329e6ee06da3f879eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36052a3a52eb60314f11e4d613c59d8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a36052a3a52eb60314f11e4d613c59d8e">is_derived_from</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a36052a3a52eb60314f11e4d613c59d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this type is derived from the given type <code>other</code>, otherwise false.  <a href="#a36052a3a52eb60314f11e4d613c59d8e">More...</a><br /></td></tr>
<tr class="separator:a36052a3a52eb60314f11e4d613c59d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59b3e5ed8937e7bd6f108fd9a8c866c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac59b3e5ed8937e7bd6f108fd9a8c866c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ac59b3e5ed8937e7bd6f108fd9a8c866c">is_derived_from</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac59b3e5ed8937e7bd6f108fd9a8c866c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this type is derived from the given type <em>T</em>, otherwise false.  <a href="#ac59b3e5ed8937e7bd6f108fd9a8c866c">More...</a><br /></td></tr>
<tr class="separator:ac59b3e5ed8937e7bd6f108fd9a8c866c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1326dec3b1a78be9b85c8f2431f634"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#abe1326dec3b1a78be9b85c8f2431f634">get_base_classes</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:abe1326dec3b1a78be9b85c8f2431f634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all base classes of this type.  <a href="#abe1326dec3b1a78be9b85c8f2431f634">More...</a><br /></td></tr>
<tr class="separator:abe1326dec3b1a78be9b85c8f2431f634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad05059929071f1772cf7dd342435f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#abad05059929071f1772cf7dd342435f3">get_derived_classes</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:abad05059929071f1772cf7dd342435f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all derived classes of this type.  <a href="#abad05059929071f1772cf7dd342435f3">More...</a><br /></td></tr>
<tr class="separator:abad05059929071f1772cf7dd342435f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825f853dc03724ff3257a194f05070d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a825f853dc03724ff3257a194f05070d5">get_metadata</a> (const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;key) const </td></tr>
<tr class="memdesc:a825f853dc03724ff3257a194f05070d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta data for the given key <code>key</code>.  <a href="#a825f853dc03724ff3257a194f05070d5">More...</a><br /></td></tr>
<tr class="separator:a825f853dc03724ff3257a194f05070d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16981b0edaeb1c3514b15bf8938b3115"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1constructor.html">constructor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a16981b0edaeb1c3514b15bf8938b3115">get_constructor</a> (const std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; &amp;params=std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt;()) const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a16981b0edaeb1c3514b15bf8938b3115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a public constructor whose parameters match the types in the specified list.  <a href="#a16981b0edaeb1c3514b15bf8938b3115">More...</a><br /></td></tr>
<tr class="separator:a16981b0edaeb1c3514b15bf8938b3115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae370beb0bb36e01e6c5440caf169e02c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1constructor.html">constructor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ae370beb0bb36e01e6c5440caf169e02c">get_constructors</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae370beb0bb36e01e6c5440caf169e02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all registered <em>public</em> constructors for this type.  <a href="#ae370beb0bb36e01e6c5440caf169e02c">More...</a><br /></td></tr>
<tr class="separator:ae370beb0bb36e01e6c5440caf169e02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea44f1a10deb3790d224c4f1d0540f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1constructor.html">constructor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#adea44f1a10deb3790d224c4f1d0540f4">get_constructors</a> (filter_items filter) const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:adea44f1a10deb3790d224c4f1d0540f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all registered constructors for this type, based on the given <code>filter</code>. The base classes are <b>not</b> included in the search.  <a href="#adea44f1a10deb3790d224c4f1d0540f4">More...</a><br /></td></tr>
<tr class="separator:adea44f1a10deb3790d224c4f1d0540f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c54948eafb21fe494afd1057117f5c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a8c54948eafb21fe494afd1057117f5c1">create</a> (std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt; args=std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt;()) const </td></tr>
<tr class="memdesc:a8c54948eafb21fe494afd1057117f5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the current type, with the given arguments <code>args</code> for the constructor.  <a href="#a8c54948eafb21fe494afd1057117f5c1">More...</a><br /></td></tr>
<tr class="separator:a8c54948eafb21fe494afd1057117f5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1583b3f6dbe00caa570fb42dcaff0bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1destructor.html">destructor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ae1583b3f6dbe00caa570fb42dcaff0bf">get_destructor</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae1583b3f6dbe00caa570fb42dcaff0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the corresponding destructor for this type.  <a href="#ae1583b3f6dbe00caa570fb42dcaff0bf">More...</a><br /></td></tr>
<tr class="separator:ae1583b3f6dbe00caa570fb42dcaff0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae249958bc89e70eeea4534379b2d0967"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ae249958bc89e70eeea4534379b2d0967">destroy</a> (<a class="el" href="classrttr_1_1variant.html">variant</a> &amp;<a class="el" href="method__default__arg__test_8cpp.html#a07a6ff178aa769e87c7388d6baeff2b8">obj</a>) const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae249958bc89e70eeea4534379b2d0967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the contained object in the variant <code>obj</code>.  <a href="#ae249958bc89e70eeea4534379b2d0967">More...</a><br /></td></tr>
<tr class="separator:ae249958bc89e70eeea4534379b2d0967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2f2e1cb28feb0c7372573423d866ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1property.html">property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a8f2f2e1cb28feb0c7372573423d866ff">get_property</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name) const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8f2f2e1cb28feb0c7372573423d866ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a property with the name <code>name</code>.  <a href="#a8f2f2e1cb28feb0c7372573423d866ff">More...</a><br /></td></tr>
<tr class="separator:a8f2f2e1cb28feb0c7372573423d866ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47204aeb63b96917f6bbbdce39726fb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1property.html">property</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a47204aeb63b96917f6bbbdce39726fb9">get_properties</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a47204aeb63b96917f6bbbdce39726fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all registered <em>public</em> properties for this type and all its base classes.  <a href="#a47204aeb63b96917f6bbbdce39726fb9">More...</a><br /></td></tr>
<tr class="separator:a47204aeb63b96917f6bbbdce39726fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc194b1ed42cf0b8a8421fc908a30ac8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1property.html">property</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#afc194b1ed42cf0b8a8421fc908a30ac8">get_properties</a> (filter_items filter) const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:afc194b1ed42cf0b8a8421fc908a30ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all registered properties for this type, based on the given <code>filter</code>. The base classes are included in the search.  <a href="#afc194b1ed42cf0b8a8421fc908a30ac8">More...</a><br /></td></tr>
<tr class="separator:afc194b1ed42cf0b8a8421fc908a30ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8ae257da593310bfc4364c48647103"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a4e8ae257da593310bfc4364c48647103">get_property_value</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name, <a class="el" href="classrttr_1_1instance.html">instance</a> <a class="el" href="method__default__arg__test_8cpp.html#a07a6ff178aa769e87c7388d6baeff2b8">obj</a>) const </td></tr>
<tr class="memdesc:a4e8ae257da593310bfc4364c48647103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property value of property named <code>name</code> from the instance <code>obj</code>.  <a href="#a4e8ae257da593310bfc4364c48647103">More...</a><br /></td></tr>
<tr class="separator:a4e8ae257da593310bfc4364c48647103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4348f6d732721f82cff442f2c0b64d40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a4348f6d732721f82cff442f2c0b64d40">set_property_value</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name, <a class="el" href="classrttr_1_1instance.html">instance</a> <a class="el" href="method__default__arg__test_8cpp.html#a07a6ff178aa769e87c7388d6baeff2b8">obj</a>, <a class="el" href="classrttr_1_1argument.html">argument</a> arg) const </td></tr>
<tr class="memdesc:a4348f6d732721f82cff442f2c0b64d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set the given value <code>arg</code> to a property named <code>name</code> to the instance <code>obj</code>.  <a href="#a4348f6d732721f82cff442f2c0b64d40">More...</a><br /></td></tr>
<tr class="separator:a4348f6d732721f82cff442f2c0b64d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f3a8922d0afafa4c609eb6a600c905"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1method.html">method</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#af3f3a8922d0afafa4c609eb6a600c905">get_method</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name) const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:af3f3a8922d0afafa4c609eb6a600c905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a method with the name <code>name</code>.  <a href="#af3f3a8922d0afafa4c609eb6a600c905">More...</a><br /></td></tr>
<tr class="separator:af3f3a8922d0afafa4c609eb6a600c905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c1187aa22b5bdca32c782b42d02e2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1method.html">method</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a47c1187aa22b5bdca32c782b42d02e2a">get_method</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name, const std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; &amp;type_list) const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a47c1187aa22b5bdca32c782b42d02e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a method with the name <code>name</code> which match the given parameter type list <code>type_list</code>.  <a href="#a47c1187aa22b5bdca32c782b42d02e2a">More...</a><br /></td></tr>
<tr class="separator:a47c1187aa22b5bdca32c782b42d02e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac25a57e82c6603bf2fd9813bbf635c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1method.html">method</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aac25a57e82c6603bf2fd9813bbf635c7">get_methods</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:aac25a57e82c6603bf2fd9813bbf635c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all registered <em>public</em> methods for this type and all its base classes.  <a href="#aac25a57e82c6603bf2fd9813bbf635c7">More...</a><br /></td></tr>
<tr class="separator:aac25a57e82c6603bf2fd9813bbf635c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4abe165174293ee4fd76d0d34d8b6a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1method.html">method</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ac4abe165174293ee4fd76d0d34d8b6a7">get_methods</a> (filter_items filter) const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac4abe165174293ee4fd76d0d34d8b6a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all registered methods for this type, based on the given <code>filter</code>. The base classes are included in the search.  <a href="#ac4abe165174293ee4fd76d0d34d8b6a7">More...</a><br /></td></tr>
<tr class="separator:ac4abe165174293ee4fd76d0d34d8b6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d399ace70b2799d7bb6dab147e09a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aa9d399ace70b2799d7bb6dab147e09a7">invoke</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name, <a class="el" href="classrttr_1_1instance.html">instance</a> <a class="el" href="method__default__arg__test_8cpp.html#a07a6ff178aa769e87c7388d6baeff2b8">obj</a>, std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt; args) const </td></tr>
<tr class="memdesc:aa9d399ace70b2799d7bb6dab147e09a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>.  <a href="#aa9d399ace70b2799d7bb6dab147e09a7">More...</a><br /></td></tr>
<tr class="separator:aa9d399ace70b2799d7bb6dab147e09a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246f49f50c89f13efacf5e20e199d80c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a246f49f50c89f13efacf5e20e199d80c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a246f49f50c89f13efacf5e20e199d80c">get</a> () <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="separator:a246f49f50c89f13efacf5e20e199d80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c6e144616533fed61d9262f2983e77"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae7c6e144616533fed61d9262f2983e77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ae7c6e144616533fed61d9262f2983e77">get</a> (T &amp;&amp;object) <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="separator:ae7c6e144616533fed61d9262f2983e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e20a25e9a463afa034d74cebaed0f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a83e20a25e9a463afa034d74cebaed0f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a83e20a25e9a463afa034d74cebaed0f7">is_derived_from</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="separator:a83e20a25e9a463afa034d74cebaed0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9917f69110374141da3f045ac23247"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:aee9917f69110374141da3f045ac23247"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aee9917f69110374141da3f045ac23247">register_converter_func</a> (F func)</td></tr>
<tr class="separator:aee9917f69110374141da3f045ac23247"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7cca313037c5f6da7ece8c0f24c48450"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7cca313037c5f6da7ece8c0f24c48450"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a7cca313037c5f6da7ece8c0f24c48450">get</a> () <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7cca313037c5f6da7ece8c0f24c48450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type object for the given template type <em>T</em>.  <a href="#a7cca313037c5f6da7ece8c0f24c48450">More...</a><br /></td></tr>
<tr class="separator:a7cca313037c5f6da7ece8c0f24c48450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38f41ee6e8f8c0e3da14e6967feecd2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa38f41ee6e8f8c0e3da14e6967feecd2"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aa38f41ee6e8f8c0e3da14e6967feecd2">get</a> (T &amp;&amp;object) <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa38f41ee6e8f8c0e3da14e6967feecd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type object for the given instance <em>object</em>.  <a href="#aa38f41ee6e8f8c0e3da14e6967feecd2">More...</a><br /></td></tr>
<tr class="separator:aa38f41ee6e8f8c0e3da14e6967feecd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314353ed1201f0f0b6d2777a574241e9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a314353ed1201f0f0b6d2777a574241e9">get_by_name</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name) <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a314353ed1201f0f0b6d2777a574241e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type object with the given name <code>name</code>.  <a href="#a314353ed1201f0f0b6d2777a574241e9">More...</a><br /></td></tr>
<tr class="separator:a314353ed1201f0f0b6d2777a574241e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43763949ea84a5ebcd11eb98c3aa87cd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a43763949ea84a5ebcd11eb98c3aa87cd">get_types</a> () <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a43763949ea84a5ebcd11eb98c3aa87cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all registered type objects.  <a href="#a43763949ea84a5ebcd11eb98c3aa87cd">More...</a><br /></td></tr>
<tr class="separator:a43763949ea84a5ebcd11eb98c3aa87cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ef08452fcfab099780c2c7a1cf712e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1property.html">property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aa2ef08452fcfab099780c2c7a1cf712e">get_global_property</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name) <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa2ef08452fcfab099780c2c7a1cf712e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a global property with the name <code>name</code>.  <a href="#aa2ef08452fcfab099780c2c7a1cf712e">More...</a><br /></td></tr>
<tr class="separator:aa2ef08452fcfab099780c2c7a1cf712e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57db85519724768e4856311adf64cae"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1property.html">property</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ad57db85519724768e4856311adf64cae">get_global_properties</a> () <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad57db85519724768e4856311adf64cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all registered global properties.  <a href="#ad57db85519724768e4856311adf64cae">More...</a><br /></td></tr>
<tr class="separator:ad57db85519724768e4856311adf64cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364b1e09b2808a0bf0b754507f4f8371"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a364b1e09b2808a0bf0b754507f4f8371">get_property_value</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name)</td></tr>
<tr class="memdesc:a364b1e09b2808a0bf0b754507f4f8371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property value of property named <code>name</code>.  <a href="#a364b1e09b2808a0bf0b754507f4f8371">More...</a><br /></td></tr>
<tr class="separator:a364b1e09b2808a0bf0b754507f4f8371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a1c5cadec4686935e4ac6ea11ea2e5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#af1a1c5cadec4686935e4ac6ea11ea2e5">set_property_value</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name, <a class="el" href="classrttr_1_1argument.html">argument</a> arg)</td></tr>
<tr class="memdesc:af1a1c5cadec4686935e4ac6ea11ea2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set the given value <code>arg</code> to a property named <code>name</code>.  <a href="#af1a1c5cadec4686935e4ac6ea11ea2e5">More...</a><br /></td></tr>
<tr class="separator:af1a1c5cadec4686935e4ac6ea11ea2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8633509bb339e03a08ba97ee4d84265b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1method.html">method</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a8633509bb339e03a08ba97ee4d84265b">get_global_method</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name) <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8633509bb339e03a08ba97ee4d84265b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a global method with the name <code>name</code>.  <a href="#a8633509bb339e03a08ba97ee4d84265b">More...</a><br /></td></tr>
<tr class="separator:a8633509bb339e03a08ba97ee4d84265b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5140dc950f27b78d454110b5d1c8788d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1method.html">method</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a5140dc950f27b78d454110b5d1c8788d">get_global_method</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name, const std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; &amp;params) <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5140dc950f27b78d454110b5d1c8788d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a global method with the name <code>name</code> which match the given parameter list <code>params</code>.  <a href="#a5140dc950f27b78d454110b5d1c8788d">More...</a><br /></td></tr>
<tr class="separator:a5140dc950f27b78d454110b5d1c8788d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d05aa655fa068efcc968bee736c716"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1method.html">method</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a90d05aa655fa068efcc968bee736c716">get_global_methods</a> () <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a90d05aa655fa068efcc968bee736c716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range of all registered global methods.  <a href="#a90d05aa655fa068efcc968bee736c716">More...</a><br /></td></tr>
<tr class="separator:a90d05aa655fa068efcc968bee736c716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c98a053d697eb61600db84cac1db2b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a48c98a053d697eb61600db84cac1db2b">invoke</a> (<a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> name, std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt; args)</td></tr>
<tr class="memdesc:a48c98a053d697eb61600db84cac1db2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a global method named <code>name</code> with the specified argument <code>args</code>.  <a href="#a48c98a053d697eb61600db84cac1db2b">More...</a><br /></td></tr>
<tr class="separator:a48c98a053d697eb61600db84cac1db2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f5f2ea31cc79846a829aa5737680f0"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a81f5f2ea31cc79846a829aa5737680f0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">register_converter_func</a> (F func)</td></tr>
<tr class="memdesc:a81f5f2ea31cc79846a829aa5737680f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a converter func <code>F</code>, which will be used internally by the <a class="el" href="classrttr_1_1variant.html">variant</a> class to convert between types.  <a href="#a81f5f2ea31cc79846a829aa5737680f0">More...</a><br /></td></tr>
<tr class="separator:a81f5f2ea31cc79846a829aa5737680f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2c17776d13e346422843aefeb4ccca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adc2c17776d13e346422843aefeb4ccca"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#adc2c17776d13e346422843aefeb4ccca">register_comparators</a> ()</td></tr>
<tr class="memdesc:adc2c17776d13e346422843aefeb4ccca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register comparison operators for template type <code>T</code>. This requires a valid <code>operator==</code> and <code>operator&lt;</code> for type <code>T</code>.  <a href="#adc2c17776d13e346422843aefeb4ccca">More...</a><br /></td></tr>
<tr class="separator:adc2c17776d13e346422843aefeb4ccca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a49052ea345144252dd6903bffa267c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2a49052ea345144252dd6903bffa267c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a2a49052ea345144252dd6903bffa267c">register_equal_comparator</a> ()</td></tr>
<tr class="memdesc:a2a49052ea345144252dd6903bffa267c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the equal comparison operators for template type <code>T</code>. This requires a valid <code>operator==</code> for type <code>T</code>.  <a href="#a2a49052ea345144252dd6903bffa267c">More...</a><br /></td></tr>
<tr class="separator:a2a49052ea345144252dd6903bffa267c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd1ce4cd4597780446594ff1ae35840"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aefd1ce4cd4597780446594ff1ae35840"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aefd1ce4cd4597780446594ff1ae35840">register_less_than_comparator</a> ()</td></tr>
<tr class="memdesc:aefd1ce4cd4597780446594ff1ae35840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the less than comparison operators for template type <code>T</code>. This requires a valid <code>operator&lt;</code> for type <code>T</code>.  <a href="#aefd1ce4cd4597780446594ff1ae35840">More...</a><br /></td></tr>
<tr class="separator:aefd1ce4cd4597780446594ff1ae35840"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ae1a4b3fe8db8012f2feed6f16d9c5fad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ae1a4b3fe8db8012f2feed6f16d9c5fad">type</a> () <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="separator:ae1a4b3fe8db8012f2feed6f16d9c5fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9ee3f4005f843c44e03b35871513d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a5e9ee3f4005f843c44e03b35871513d0">type</a> (<a class="el" href="structrttr_1_1detail_1_1type__data.html">detail::type_data</a> *data) <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5e9ee3f4005f843c44e03b35871513d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a valid type object.  <a href="#a5e9ee3f4005f843c44e03b35871513d0">More...</a><br /></td></tr>
<tr class="separator:a5e9ee3f4005f843c44e03b35871513d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab2d32a4853103498bac697e3aeb096"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structrttr_1_1detail_1_1type__converter__base.html">detail::type_converter_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a0ab2d32a4853103498bac697e3aeb096">get_type_converter</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;target_type) const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0ab2d32a4853103498bac697e3aeb096"><td class="mdescLeft">&#160;</td><td class="mdescRight">When for the current type instance a converter function to type <code>target_type</code> was registered, then this function returns a valid pointer to a type_converter_base object. Otherwise this function returns a nullptr.  <a href="#a0ab2d32a4853103498bac697e3aeb096">More...</a><br /></td></tr>
<tr class="separator:a0ab2d32a4853103498bac697e3aeb096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5ef0ede1183c851d741213cfafba22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a7d5ef0ede1183c851d741213cfafba22">get_pointer_dimension</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7d5ef0ede1183c851d741213cfafba22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the level of indirection for this this type. A.k.a pointer count. E.g. (<code>int</code> will return <code>0</code>; <code>int*</code> will return <code>1</code>; <code>int**</code> will return <code>2</code>; etc...)  <a href="#a7d5ef0ede1183c851d741213cfafba22">More...</a><br /></td></tr>
<tr class="separator:a7d5ef0ede1183c851d741213cfafba22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac824230d873d291293aab2cd176475b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> <a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aac824230d873d291293aab2cd176475b">get_raw_array_type</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:aac824230d873d291293aab2cd176475b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the raw type of an array E.g. for type <code>int[100]</code> it will return the type object of <code>int</code>; <code>const int[10][25]</code> will return also <code>int</code>; etc...  <a href="#aac824230d873d291293aab2cd176475b">More...</a><br /></td></tr>
<tr class="separator:aac824230d873d291293aab2cd176475b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbb297e073099f5b592d585d60961cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> <a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a5dbb297e073099f5b592d585d60961cb">get_full_name</a> () const <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5dbb297e073099f5b592d585d60961cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the compiler depended name of the type.  <a href="#a5dbb297e073099f5b592d585d60961cb">More...</a><br /></td></tr>
<tr class="separator:a5dbb297e073099f5b592d585d60961cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991a1754d5c80fa3c083c72e18704346"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> <a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a991a1754d5c80fa3c083c72e18704346">create_variant</a> (const <a class="el" href="classrttr_1_1argument.html">argument</a> &amp;data) const </td></tr>
<tr class="memdesc:a991a1754d5c80fa3c083c72e18704346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a variant from the given argument data.  <a href="#a991a1754d5c80fa3c083c72e18704346">More...</a><br /></td></tr>
<tr class="separator:a991a1754d5c80fa3c083c72e18704346"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a0662a4e3e958646449e0f2c779a468ac"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a0662a4e3e958646449e0f2c779a468ac">apply_offset</a> (void *<a class="el" href="method__default__arg__test_8cpp.html#a81a9ab51342918b01e019f6408b3f138">ptr</a>, const <a class="el" href="classrttr_1_1type.html">type</a> &amp;source_type, const <a class="el" href="classrttr_1_1type.html">type</a> &amp;target_type) <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0662a4e3e958646449e0f2c779a468ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function try to convert the given pointer <code>ptr</code> from the type <code>source_type</code> to the target type <code>target_type</code>.  <a href="#a0662a4e3e958646449e0f2c779a468ac">More...</a><br /></td></tr>
<tr class="separator:a0662a4e3e958646449e0f2c779a468ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaebed4cab81f8e868e166dd3a8d174b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aeaebed4cab81f8e868e166dd3a8d174b">get_derived_type</a> (void *<a class="el" href="method__default__arg__test_8cpp.html#a81a9ab51342918b01e019f6408b3f138">ptr</a>, const <a class="el" href="classrttr_1_1type.html">type</a> &amp;source_type) <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:aeaebed4cab81f8e868e166dd3a8d174b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the most derived type for the given object <code>ptr</code> of type <code>source_type</code>.  <a href="#aeaebed4cab81f8e868e166dd3a8d174b">More...</a><br /></td></tr>
<tr class="separator:aeaebed4cab81f8e868e166dd3a8d174b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29dda76c1bd59dacbe1a1281832c7939"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a29dda76c1bd59dacbe1a1281832c7939">init_globals</a> ()</td></tr>
<tr class="memdesc:a29dda76c1bd59dacbe1a1281832c7939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all the global variables needed to retrieve the type informations.  <a href="#a29dda76c1bd59dacbe1a1281832c7939">More...</a><br /></td></tr>
<tr class="separator:a29dda76c1bd59dacbe1a1281832c7939"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a8cad87fef71ec4fa4dfc1d274d6b53dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrttr_1_1detail_1_1type__data.html">detail::type_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a8cad87fef71ec4fa4dfc1d274d6b53dc">m_type_data</a></td></tr>
<tr class="separator:a8cad87fef71ec4fa4dfc1d274d6b53dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad4f13d06475a06f860c63bc68d0c8a4b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ad4f13d06475a06f860c63bc68d0c8a4b">variant</a></td></tr>
<tr class="separator:ad4f13d06475a06f860c63bc68d0c8a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b46cb31e07e852c62c550f358671b0d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enable &gt; </td></tr>
<tr class="memitem:a0b46cb31e07e852c62c550f358671b0d"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a0b46cb31e07e852c62c550f358671b0d">detail::type_getter</a></td></tr>
<tr class="separator:a0b46cb31e07e852c62c550f358671b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be882f1f7adb23031cabee74d6d1699"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a4be882f1f7adb23031cabee74d6d1699">instance</a></td></tr>
<tr class="separator:a4be882f1f7adb23031cabee74d6d1699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac397ff81d3c07fd5c1711b3b37a95ac"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aac397ff81d3c07fd5c1711b3b37a95ac">detail::type_register</a></td></tr>
<tr class="separator:aac397ff81d3c07fd5c1711b3b37a95ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5983fa63738d32e629a0055af54da47"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ab5983fa63738d32e629a0055af54da47">detail::type_register_private</a></td></tr>
<tr class="separator:ab5983fa63738d32e629a0055af54da47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786039d5bfd109c54b9b375809b6da80"><td class="memTemplParams" colspan="2">template&lt;typename Target_Type , typename Source_Type &gt; </td></tr>
<tr class="memitem:a786039d5bfd109c54b9b375809b6da80"><td class="memTemplItemLeft" align="right" valign="top">Target_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a786039d5bfd109c54b9b375809b6da80">rttr_cast</a> (Source_Type object) <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="memdesc:a786039d5bfd109c54b9b375809b6da80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the given <code>object</code> of type <code>Source_Type</code> to an object of type <code>Target_Type</code>.  <a href="#a786039d5bfd109c54b9b375809b6da80">More...</a><br /></td></tr>
<tr class="separator:a786039d5bfd109c54b9b375809b6da80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e95db5d7eb2176229cdd6cd5d7e9a95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a6e95db5d7eb2176229cdd6cd5d7e9a95">detail::get_invalid_type</a> () <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="separator:a6e95db5d7eb2176229cdd6cd5d7e9a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23d84cbf46a62ef9615e256230aafd1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac23d84cbf46a62ef9615e256230aafd1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structrttr_1_1detail_1_1type__data.html">detail::type_data</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ac23d84cbf46a62ef9615e256230aafd1">detail::get_type_data</a> () <a class="el" href="core__prerequisites_8h.html#a3ab7a1bb42e15207cbeedbf6882048c0">RTTR_NOEXCEPT</a></td></tr>
<tr class="separator:ac23d84cbf46a62ef9615e256230aafd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classrttr_1_1type.html">type</a> class holds the type information for any arbitrary object.</p>
<p>Every class or primitive data type can have an unique type object. With the help of this object you can compare unknown types for equality at runtime or introspect the type for its <a class="el" href="classrttr_1_1property.html">properties</a>, <a class="el" href="classrttr_1_1method.html">methods</a>, <a class="el" href="classrttr_1_1enumeration.html">enumerations</a>, <a class="el" href="classrttr_1_1constructor.html">constructors</a> and <a class="el" href="classrttr_1_1destructor.html">destructor</a>.</p>
<h2>Retrieve type </h2>
<p>A type object <b>cannot</b> be created. It is only possible to retrieve a type object via three static template member functions:</p>
<h3><a class="el" href="classrttr_1_1type.html#a7cca313037c5f6da7ece8c0f24c48450" title="Returns a type object for the given template type T. ">type::get&lt;T&gt;()</a></h3>
<p>This function just expects one template argument. Use it to check against a known type.</p>
<div class="fragment"><div class="line">type::get&lt;int&gt;() == type::get&lt;int&gt;();  <span class="comment">// yields to true</span></div>
<div class="line">type::get&lt;int&gt;() == type::get&lt;bool&gt;(); <span class="comment">// yields to false</span></div>
</div><!-- fragment --><h3><a class="el" href="classrttr_1_1type.html#a314353ed1201f0f0b6d2777a574241e9" title="Returns the type object with the given name name. ">type::get_by_name(string_view)</a></h3>
<p>This function just expects the name of the type. This is useful when you know only the name of the type and cannot include the type itself into the source code.</p>
<div class="fragment"><div class="line"><a class="code" href="classrttr_1_1type.html#a314353ed1201f0f0b6d2777a574241e9">type::get_by_name</a>(<span class="stringliteral">&quot;int&quot;</span>)  == type::get&lt;int&gt;(); <span class="comment">// yields to true</span></div>
<div class="line"><a class="code" href="classrttr_1_1type.html#a314353ed1201f0f0b6d2777a574241e9">type::get_by_name</a>(<span class="stringliteral">&quot;bool&quot;</span>) == type::get&lt;int&gt;(); <span class="comment">// yields to false</span></div>
<div class="line"><a class="code" href="classrttr_1_1type.html#a314353ed1201f0f0b6d2777a574241e9">type::get_by_name</a>(<span class="stringliteral">&quot;MyNameSpace::MyStruct&quot;</span>) == type::get&lt;MyNameSpace::MyStruct&gt;();  <span class="comment">// yields to true</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>Before using the function <a class="el" href="classrttr_1_1type.html#a314353ed1201f0f0b6d2777a574241e9">type::get_by_name()</a>, you have to use one time the function via <a class="el" href="classrttr_1_1type.html#a7cca313037c5f6da7ece8c0f24c48450">type::get&lt;T&gt;()</a>, otherwise the type is not registered in the type system.</dd></dl>
<h3><a class="el" href="classrttr_1_1type.html#aa38f41ee6e8f8c0e3da14e6967feecd2" title="Returns a type object for the given instance object. ">type::get&lt;T&gt;(T&amp;&amp; obj)</a></h3>
<p>This function takes a universal reference and returns from every given object the corresponding type object.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> int_obj;</div>
<div class="line"><span class="keywordtype">int</span>* int_obj_ptr = &amp;int_obj;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span>* c_int_obj_ptr = int_obj_ptr;</div>
<div class="line"></div>
<div class="line">type::get&lt;int&gt;()         == <a class="code" href="classrttr_1_1type.html#a7cca313037c5f6da7ece8c0f24c48450">type::get</a>(int_obj);        <span class="comment">// yields to true</span></div>
<div class="line">type::get&lt;int*&gt;()        == <a class="code" href="classrttr_1_1type.html#a7cca313037c5f6da7ece8c0f24c48450">type::get</a>(int_obj_ptr);    <span class="comment">// yields to true</span></div>
<div class="line">type::get&lt;const int*&gt;()  == <a class="code" href="classrttr_1_1type.html#a7cca313037c5f6da7ece8c0f24c48450">type::get</a>(c_int_obj_ptr);  <span class="comment">// yields to true</span></div>
</div><!-- fragment --><p>When this function is called for a glvalue expression whose type is a polymorphic class type, then the result refers to a <a class="el" href="classrttr_1_1type.html">type</a> object representing the type of the most derived object.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Base { <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>() };</div>
<div class="line"><span class="keyword">struct </span>Derived : Base { <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>(Base) };</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line">Derived d;</div>
<div class="line">Base&amp; base = d;</div>
<div class="line">type::get&lt;Derived&gt;()   == <a class="code" href="classrttr_1_1type.html#a7cca313037c5f6da7ece8c0f24c48450">type::get</a>(base);      <span class="comment">// yields to true</span></div>
<div class="line">type::get&lt;Base&gt;()      == <a class="code" href="classrttr_1_1type.html#a7cca313037c5f6da7ece8c0f24c48450">type::get</a>(base);      <span class="comment">// yields to false</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// remark, when called with pointers:</span></div>
<div class="line">Base* base_ptr = &amp;d;</div>
<div class="line">type::get&lt;Derived&gt;()   == <a class="code" href="classrttr_1_1type.html#a7cca313037c5f6da7ece8c0f24c48450">type::get</a>(base_ptr);  <span class="comment">// yields to false</span></div>
<div class="line">type::get&lt;Base*&gt;()     == <a class="code" href="classrttr_1_1type.html#a7cca313037c5f6da7ece8c0f24c48450">type::get</a>(base_ptr);  <span class="comment">// yields to true</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>If the type of the expression is a cv-qualified type, the result of the <a class="el" href="classrttr_1_1type.html#a7cca313037c5f6da7ece8c0f24c48450" title="Returns a type object for the given template type T. ">rttr::type::get</a> expression refers to a <a class="el" href="classrttr_1_1type.html">rttr::type</a> object representing the cv-unqualified type.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">class </span>D { ... };</div>
<div class="line">D d1;</div>
<div class="line"><span class="keyword">const</span> D d2;</div>
<div class="line"><a class="code" href="classrttr_1_1type.html#a7cca313037c5f6da7ece8c0f24c48450">type::get</a>(d1)  == <a class="code" href="classrttr_1_1type.html#a7cca313037c5f6da7ece8c0f24c48450">type::get</a>(d2);         <span class="comment">// yields true</span></div>
<div class="line">type::get&lt;D&gt;() == type::get&lt;const D&gt;();  <span class="comment">// yields true</span></div>
<div class="line">type::get&lt;D&gt;() == <a class="code" href="classrttr_1_1type.html#a7cca313037c5f6da7ece8c0f24c48450">type::get</a>(d2);         <span class="comment">// yields true</span></div>
<div class="line">type::get&lt;D&gt;() == type::get&lt;const D&amp;&gt;(); <span class="comment">// yields true</span></div>
<div class="line">type::get&lt;D&gt;() == type::get&lt;const D*&gt;(); <span class="comment">// yields false</span></div>
</div><!-- fragment --><p> Any <code>top level</code> cv-qualifier of the given type <code>T</code> will be removed.</p>
<h2>Copying and Assignment </h2>
<p>A <a class="el" href="classrttr_1_1type.html">type</a> object is lightweight and can be copied by value. However, each copy will refer to the same underlying type. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aa51c17659f86333038379c23b03d2db0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t <a class="el" href="classrttr_1_1type.html#aa51c17659f86333038379c23b03d2db0">rttr::type::type_id</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aca76e402ae8dc21e8489cf190960b738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> rttr::type::type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a type to another one. </p>

</div>
</div>
<a class="anchor" id="ae1a4b3fe8db8012f2feed6f16d9c5fad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> rttr::type::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an empty and invalid type object. </p>

</div>
</div>
<a class="anchor" id="a5e9ee3f4005f843c44e03b35871513d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> rttr::type::type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrttr_1_1detail_1_1type__data.html">detail::type_data</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a valid type object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The unique id of the data type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0662a4e3e958646449e0f2c779a468ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * rttr::type::apply_offset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>source_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>target_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function try to convert the given pointer <code>ptr</code> from the type <code>source_type</code> to the target type <code>target_type</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The returned pointer is always the raw type of <code>target_type</code>. You do not have to use this function by your own.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the converted pointer; when the conversion fails is a null pointer is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c54948eafb21fe494afd1057117f5c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::create </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em> = <code>std::vector&lt;<a class="el" href="classrttr_1_1argument.html">argument</a>&gt;()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the current type, with the given arguments <code>args</code> for the constructor. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When the argument types does not match the parameter list of the constructor then the he will not be invoked. Constructors with registered <a class="el" href="namespacerttr.html#a24de496245cbff4825ee72e482ffac42">default_arguments</a> will be honored.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an instance of the given type. </dd></dl>

</div>
</div>
<a class="anchor" id="a991a1754d5c80fa3c083c72e18704346"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> <a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::create_variant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1argument.html">argument</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a variant from the given argument data. </p>

</div>
</div>
<a class="anchor" id="ae249958bc89e70eeea4534379b2d0967"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the contained object in the variant <code>obj</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When the <code>obj</code> could be destroyed the given <code>obj</code> is invalid after calling this method; Otherwise it is still valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the destructor of the object could be invoked, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a7cca313037c5f6da7ece8c0f24c48450"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a type object for the given template type <em>T</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>type for the template type <em>T</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa38f41ee6e8f8c0e3da14e6967feecd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a type object for the given instance <em>object</em>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the type of the expression is a cv-qualified type, the result of the <a class="el" href="classrttr_1_1type.html#a7cca313037c5f6da7ece8c0f24c48450" title="Returns a type object for the given template type T. ">type::get()</a> expression refers to a type object representing the cv-unqualified type. When <a class="el" href="classrttr_1_1type.html#a7cca313037c5f6da7ece8c0f24c48450" title="Returns a type object for the given template type T. ">type::get()</a> is applied to a glvalue expression whose type is a polymorphic class type, the result refers to a type object representing the type of the most derived object.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>type for an <em>object</em> of type <em>T</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a246f49f50c89f13efacf5e20e199d80c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae7c6e144616533fed61d9262f2983e77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abe1326dec3b1a78be9b85c8f2431f634"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; rttr::type::get_base_classes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a range of all base classes of this type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Make sure that the complete class hierarchy has the macro RTTR_ENABLE inside the class declaration, otherwise the returned information of this function is <b>not correct</b>. The order of this list depends on the declaration order of classes inside RTTR_ENABLE. E.g. <a class="el" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE(A1, A2)</a> =&gt; A1 will be for A2 in the list. Accordingly the root (or parent or base) class is always the first type in the list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of types. </dd></dl>

</div>
</div>
<a class="anchor" id="a314353ed1201f0f0b6d2777a574241e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get_by_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type object with the given name <code>name</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The search for the type is case sensitive. White spaces will be ignored. The name of the type corresponds to the name which was used during <a class="el" href="_interpolators_test_8cpp.html#aa85998502208f6b5493127968965072a">RTTR_REGISTRATION</a>. Only after the registration process was executed, then the type can be retrieved with this function. Otherwise and invalid type will be returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classrttr_1_1type.html">type</a> object with the name <code>name</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a16981b0edaeb1c3514b15bf8938b3115"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1constructor.html">constructor</a> rttr::type::get_constructor </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em> = <code>std::vector&lt;<a class="el" href="classrttr_1_1type.html">type</a>&gt;()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a public constructor whose parameters match the types in the specified list. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When no parameter list is given, it will be searched for the default constructor.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A valid constructor will be returned when the parameter matches the registered constructor; otherwise an invalid constructor. </dd></dl>

</div>
</div>
<a class="anchor" id="ae370beb0bb36e01e6c5440caf169e02c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1constructor.html">constructor</a> &gt; rttr::type::get_constructors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a range of all registered <em>public</em> constructors for this type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>In order to retrieve <em>private</em> constructors, use <a class="el" href="classrttr_1_1type.html#adea44f1a10deb3790d224c4f1d0540f4">type::get_constructors(filter_items) const</a> with following filter combination <code><a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f" title="Includes all members in the search, which needs an instance to be invoked. ">filter_item::instance_item</a> | <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a73f4306dc59f7bb3db095d000e0c0e4d" title="Includes all static members in the search. Static members doesn&#39;t need any instance for invoking...">filter_item::static_item</a> | <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32" title="Includes all non public (private or protected) members in the search. ">filter_item::non_public_access</a></code> The constructors are sorted after its order of registration.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of constructors. </dd></dl>

</div>
</div>
<a class="anchor" id="adea44f1a10deb3790d224c4f1d0540f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1constructor.html">constructor</a> &gt; rttr::type::get_constructors </td>
          <td>(</td>
          <td class="paramtype">filter_items&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a range of all registered constructors for this type, based on the given <code>filter</code>. The base classes are <b>not</b> included in the search. </p>
<p>Combine the enum values inside <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7">filter_item</a> with the OR operator to return a certain range of constructors.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rttr/registration&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>my_struct { my_struct() {} my_struct(<span class="keywordtype">int</span>) {} my_struct(<span class="keywordtype">bool</span>) {} <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>() };</div>
<div class="line"></div>
<div class="line"><a class="code" href="registration__impl_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classrttr_1_1registration_1_1class__.html">rttr::registration::class_&lt;my_struct&gt;</a>(<span class="stringliteral">&quot;my_struct&quot;</span>)</div>
<div class="line">        .constructor&lt;&gt;() ( <a class="code" href="structrttr_1_1policy_1_1ctor.html#a1e3b8ee81a41ce6b2e075bef1620f28c">policy::ctor::as_object</a> )</div>
<div class="line">        .constructor&lt;bool&gt;(<a class="code" href="classrttr_1_1registration.html#a14791e5b4d41875bed9adce2b8d4b36b">registration::protected_access</a>) ( <a class="code" href="structrttr_1_1policy_1_1ctor.html#a1e3b8ee81a41ce6b2e075bef1620f28c">policy::ctor::as_object</a> )</div>
<div class="line">        .constructor&lt;int&gt;() ( <a class="code" href="structrttr_1_1policy_1_1ctor.html#a1e3b8ee81a41ce6b2e075bef1620f28c">policy::ctor::as_object</a> );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="sw_g_u_i_2_tests_2_prototyper_g_u_i_2main_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classrttr_1_1type.html#ae1a4b3fe8db8012f2feed6f16d9c5fad">type</a> t = rttr::type::get&lt;my_struct&gt;();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; ctor : t.get_constructors())</div>
<div class="line">        std::cout &lt;&lt; ctor.get_signature() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;my_struct( ), my_struct( int ),&quot;</span></div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; ctor : t.get_constructors(<a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f">filter_item::instance_item</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32">filter_item::non_public_access</a>))</div>
<div class="line">        std::cout &lt;&lt; ctor.get_signature() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;my_struct( bool ),&quot;</span></div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; ctor : t.get_constructors(<a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a73f4306dc59f7bb3db095d000e0c0e4d">filter_item::static_item</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32">filter_item::non_public_access</a>))</div>
<div class="line">        std::cout &lt;&lt; ctor.get_signature() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;my_struct( bool ),&quot;</span></div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; ctor : t.get_constructors(<a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f">filter_item::instance_item</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a84807fec67699af41c7bcb3a57dce40b">filter_item::public_access</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa2b50631fca90a55025de5c85b6448da">filter_item::declared_only</a>))</div>
<div class="line">        std::cout &lt;&lt; ctor.get_signature() &lt;&lt; std::endl; <span class="comment">// prints &quot;my_struct( ), my_struct( int ),&quot;</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>The properties are sorted after its order of registration.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of properties. </dd></dl>

</div>
</div>
<a class="anchor" id="abad05059929071f1772cf7dd342435f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; rttr::type::get_derived_classes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a range of all derived classes of this type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Make sure that the complete class hierarchy has the macro RTTR_ENABLE inside the class declaration, otherwise the returned information of this function is <b>not correct</b>. The order of this list depends on the declaration order of classes inside RTTR_ENABLE. E.g. <a class="el" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE(A1, A2)</a> =&gt; A1 will be for A2 in the list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of type objects. </dd></dl>

</div>
</div>
<a class="anchor" id="aeaebed4cab81f8e868e166dd3a8d174b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get_derived_type </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>source_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the most derived type for the given object <code>ptr</code> of type <code>source_type</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the most derived type for the given instance <code>ptr</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1583b3f6dbe00caa570fb42dcaff0bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1destructor.html">destructor</a> rttr::type::get_destructor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the corresponding destructor for this type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there is no constructor registered for this type, then also the destructor is not available. A destructor will always been automatically registered.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the destructor for this type. </dd></dl>

</div>
</div>
<a class="anchor" id="a91717a96f558d7f3399addd1890c2c8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1enumeration.html">enumeration</a> rttr::type::get_enumeration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the enumerator if this type is an enum type; otherwise the returned value is <a class="el" href="classrttr_1_1enumeration.html#aa7cb3e8546e71aa7b21595df49dce48c">not valid</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1type.html#a0b43b346aec24514269d9cd2d76ddd7d" title="Returns true whether the given type represents an enumeration. ">is_enumeration()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A enumeration object. </dd></dl>

</div>
</div>
<a class="anchor" id="a5dbb297e073099f5b592d585d60961cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> <a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> rttr::type::get_full_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the compiler depended name of the type. </p>
<dl class="section return"><dt>Returns</dt><dd>The full type name. </dd></dl>

</div>
</div>
<a class="anchor" id="a8633509bb339e03a08ba97ee4d84265b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1method.html">method</a> rttr::type::get_global_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a global method with the name <code>name</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there exists no method with the name <code>name</code>, and invalid method is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A method with name <code>name</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5140dc950f27b78d454110b5d1c8788d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1method.html">method</a> rttr::type::get_global_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a global method with the name <code>name</code> which match the given parameter list <code>params</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there exists no method with the name <code>name</code> and matching parameter list <code>params</code>, then an invalid method is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A method with name <code>name</code> and parameter signature <code>params</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a90d05aa655fa068efcc968bee736c716"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1method.html">method</a> &gt; rttr::type::get_global_methods </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range of all registered global methods. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The order of the methods in the range is undefined. Client code should <b>not</b> depend on the order in which methods are returned, because that order varies.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of methods. </dd></dl>

</div>
</div>
<a class="anchor" id="ad57db85519724768e4856311adf64cae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1property.html">property</a> &gt; rttr::type::get_global_properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range of all registered global properties. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The order of the properties in the range is undefined. Client code should <b>not</b> depend on the order in which properties are returned, because that order varies.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of properties. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2ef08452fcfab099780c2c7a1cf712e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1property.html">property</a> rttr::type::get_global_property </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a global property with the name <code>name</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there exists no property with the name <code>name</code>, then an invalid property is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A property with name <code>name</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aed1ca9b4cfd1b1843b3e591e1fc9de93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1type.html#aa51c17659f86333038379c23b03d2db0">type::type_id</a> rttr::type::get_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the id of this type. </p>
<dl class="section note"><dt>Note</dt><dd>This id is unique at process runtime, but the id can be changed every time the process is executed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The type id. </dd></dl>

</div>
</div>
<a class="anchor" id="a825f853dc03724ff3257a194f05070d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::get_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the meta data for the given key <code>key</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When no meta data is registered with the given <code>key</code>, an invalid <a class="el" href="classrttr_1_1variant.html">variant</a> object is returned (see <a class="el" href="classrttr_1_1variant.html#a58930eb7270f8c4824864799ede4f668">variant::is_valid</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A variant object, containing arbitrary data. </dd></dl>

</div>
</div>
<a class="anchor" id="af3f3a8922d0afafa4c609eb6a600c905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1method.html">method</a> rttr::type::get_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a method with the name <code>name</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there exists no method with the name <code>name</code>, then an invalid method is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A method with name <code>name</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a47c1187aa22b5bdca32c782b42d02e2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1method.html">method</a> rttr::type::get_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>type_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a method with the name <code>name</code> which match the given parameter type list <code>type_list</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there exists no method with the name <code>name</code> and matching parameter type list <code>type_list</code>, then an invalid method is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A method with name <code>name</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aac25a57e82c6603bf2fd9813bbf635c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1method.html">method</a> &gt; rttr::type::get_methods </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a range of all registered <em>public</em> methods for this type and all its base classes. </p>
<dl class="section remark"><dt>Remarks</dt><dd>In order to retrieve <em>private</em> methods, use <a class="el" href="classrttr_1_1type.html#ac4abe165174293ee4fd76d0d34d8b6a7">type::get_methods(filter_items) const</a> with following filter combination <code><a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f" title="Includes all members in the search, which needs an instance to be invoked. ">filter_item::instance_item</a> | <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a73f4306dc59f7bb3db095d000e0c0e4d" title="Includes all static members in the search. Static members doesn&#39;t need any instance for invoking...">filter_item::static_item</a> | <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32" title="Includes all non public (private or protected) members in the search. ">filter_item::non_public_access</a></code> The methods are sorted after its order of registration.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of methods. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4abe165174293ee4fd76d0d34d8b6a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1method.html">method</a> &gt; rttr::type::get_methods </td>
          <td>(</td>
          <td class="paramtype">filter_items&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a range of all registered methods for this type, based on the given <code>filter</code>. The base classes are included in the search. </p>
<p>Combine the enum values inside <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7">filter_item</a> with the OR operator to return a certain range of methods.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rttr/registration&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>base { <span class="keywordtype">void</span> func_1() {} <span class="keywordtype">void</span> func_2() {} <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>() };</div>
<div class="line"><span class="keyword">struct </span>derived : base { <span class="keywordtype">void</span> func_3() {} <span class="keyword">static</span> <span class="keywordtype">void</span> func_4() {} <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>(base) };</div>
<div class="line"></div>
<div class="line"><a class="code" href="registration__impl_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classrttr_1_1registration_1_1class__.html">rttr::registration::class_&lt;base&gt;</a>(<span class="stringliteral">&quot;base&quot;</span>)</div>
<div class="line">        .<a class="code" href="test__methods_8cpp.html#a7ceeb8a2086b0480ef498ee644ac9904">method</a>(<span class="stringliteral">&quot;func_1&quot;</span>, &amp;base::func_1)</div>
<div class="line">        .method(<span class="stringliteral">&quot;func_2&quot;</span>, &amp;base::func_2, <a class="code" href="classrttr_1_1registration.html#a8920352ec53e1cd44bdec18ef5e89568">rttr::registration::private_access</a>);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classrttr_1_1registration_1_1class__.html">rttr::registration::class_&lt;derived&gt;</a>(<span class="stringliteral">&quot;derived&quot;</span>)</div>
<div class="line">        .<a class="code" href="test__methods_8cpp.html#a7ceeb8a2086b0480ef498ee644ac9904">method</a>(<span class="stringliteral">&quot;func_3&quot;</span>, &amp;derived::func_3)</div>
<div class="line">        .method(<span class="stringliteral">&quot;func_4&quot;</span>, &amp;derived::func_4, <a class="code" href="classrttr_1_1registration.html#a8920352ec53e1cd44bdec18ef5e89568">rttr::registration::private_access</a>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="sw_g_u_i_2_tests_2_prototyper_g_u_i_2main_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classrttr_1_1type.html#ae1a4b3fe8db8012f2feed6f16d9c5fad">type</a> t = rttr::type::get&lt;derived&gt;();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; meth : t.get_methods())</div>
<div class="line">        std::cout &lt;&lt; meth.get_name() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;func_1, func_3,&quot;</span></div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; meth : t.get_methods(<a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f">filter_item::instance_item</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32">filter_item::non_public_access</a>))</div>
<div class="line">        std::cout &lt;&lt; meth.get_name() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;func_2,&quot;</span></div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; meth : t.get_methods(<a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a73f4306dc59f7bb3db095d000e0c0e4d">filter_item::static_item</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32">filter_item::non_public_access</a>))</div>
<div class="line">        std::cout &lt;&lt; meth.get_name() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;func_4,&quot;</span></div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; meth : t.get_methods(<a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f">filter_item::instance_item</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a84807fec67699af41c7bcb3a57dce40b">filter_item::public_access</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa2b50631fca90a55025de5c85b6448da">filter_item::declared_only</a>))</div>
<div class="line">        std::cout &lt;&lt; meth.get_name() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;func_3,&quot;</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>The methods are sorted after its order of registration.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of methods. </dd></dl>

</div>
</div>
<a class="anchor" id="a83515d71a2de9a15e22eb43409720e78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> <a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a> rttr::type::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the unique and human-readable name of the type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The content of this string is compiler depended.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The type name. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d5ef0ede1183c851d741213cfafba22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> std::size_t rttr::type::get_pointer_dimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the level of indirection for this this type. A.k.a pointer count. E.g. (<code>int</code> will return <code>0</code>; <code>int*</code> will return <code>1</code>; <code>int**</code> will return <code>2</code>; etc...) </p>
<dl class="section return"><dt>Returns</dt><dd>The pointer dimension. </dd></dl>

</div>
</div>
<a class="anchor" id="a47204aeb63b96917f6bbbdce39726fb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1property.html">property</a> &gt; rttr::type::get_properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a range of all registered <em>public</em> properties for this type and all its base classes. </p>
<dl class="section remark"><dt>Remarks</dt><dd>In order to retrieve <em>private</em> properties, use <a class="el" href="classrttr_1_1type.html#afc194b1ed42cf0b8a8421fc908a30ac8">type::get_properties(filter_items) const</a> with following filter combination <code><a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f" title="Includes all members in the search, which needs an instance to be invoked. ">filter_item::instance_item</a> | <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a73f4306dc59f7bb3db095d000e0c0e4d" title="Includes all static members in the search. Static members doesn&#39;t need any instance for invoking...">filter_item::static_item</a> | <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32" title="Includes all non public (private or protected) members in the search. ">filter_item::non_public_access</a></code> The properties are sorted after its order of registration.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of properties. </dd></dl>

</div>
</div>
<a class="anchor" id="afc194b1ed42cf0b8a8421fc908a30ac8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1property.html">property</a> &gt; rttr::type::get_properties </td>
          <td>(</td>
          <td class="paramtype">filter_items&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a range of all registered properties for this type, based on the given <code>filter</code>. The base classes are included in the search. </p>
<p>Combine the enum values inside <a class="el" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7">filter_item</a> with the OR operator to return a certain range of properties.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rttr/registration&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>base { <span class="keywordtype">int</span> p1, p2; <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>() };</div>
<div class="line"><span class="keyword">struct </span>derived : base { <span class="keywordtype">int</span> p3; <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> p4 = 23; <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>(base) };</div>
<div class="line"></div>
<div class="line"><a class="code" href="registration__impl_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classrttr_1_1registration_1_1class__.html">rttr::registration::class_&lt;base&gt;</a>(<span class="stringliteral">&quot;base&quot;</span>)</div>
<div class="line">        .<a class="code" href="_mesh_resources_8cpp.html#a0c42e91ed29efb489adfdbed9e301669">property</a>(<span class="stringliteral">&quot;p1&quot;</span>, &amp;base::p1)</div>
<div class="line">        .property(<span class="stringliteral">&quot;p2&quot;</span>, &amp;base::p2, <a class="code" href="classrttr_1_1registration.html#a8920352ec53e1cd44bdec18ef5e89568">rttr::registration::private_access</a>);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classrttr_1_1registration_1_1class__.html">rttr::registration::class_&lt;derived&gt;</a>(<span class="stringliteral">&quot;derived&quot;</span>)</div>
<div class="line">        .<a class="code" href="_mesh_resources_8cpp.html#a0c42e91ed29efb489adfdbed9e301669">property</a>(<span class="stringliteral">&quot;p3&quot;</span>, &amp;derived::p3)</div>
<div class="line">        .property_readonly(<span class="stringliteral">&quot;p4&quot;</span>, &amp;derived::p4, <a class="code" href="classrttr_1_1registration.html#a8920352ec53e1cd44bdec18ef5e89568">rttr::registration::private_access</a>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="sw_g_u_i_2_tests_2_prototyper_g_u_i_2main_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classrttr_1_1type.html#ae1a4b3fe8db8012f2feed6f16d9c5fad">type</a> t = rttr::type::get&lt;derived&gt;();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="property__misc__test_8cpp.html#a8ce452e2268160570d4156bec8780ad1">prop</a> : t.get_properties())</div>
<div class="line">        std::cout &lt;&lt; <a class="code" href="property__misc__test_8cpp.html#a8ce452e2268160570d4156bec8780ad1">prop</a>.get_name() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;p1, p3,&quot;</span></div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="property__misc__test_8cpp.html#a8ce452e2268160570d4156bec8780ad1">prop</a> : t.get_properties(<a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f">filter_item::instance_item</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32">filter_item::non_public_access</a>))</div>
<div class="line">        std::cout &lt;&lt; meth.get_name() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;p2,&quot;</span></div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="property__misc__test_8cpp.html#a8ce452e2268160570d4156bec8780ad1">prop</a> : t.get_properties(<a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a73f4306dc59f7bb3db095d000e0c0e4d">filter_item::static_item</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa216b9e0e0a53447dbc5a38a13196f32">filter_item::non_public_access</a>))</div>
<div class="line">        std::cout &lt;&lt; meth.get_name() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;p4,&quot;</span></div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="property__misc__test_8cpp.html#a8ce452e2268160570d4156bec8780ad1">prop</a> : t.get_properties(<a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a2bd63eb4492c93757a0003915029063f">filter_item::instance_item</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7a84807fec67699af41c7bcb3a57dce40b">filter_item::public_access</a> | <a class="code" href="namespacerttr.html#a5b3814ecb941ae0fe288c8d67703ced7aa2b50631fca90a55025de5c85b6448da">filter_item::declared_only</a>))</div>
<div class="line">        std::cout &lt;&lt; meth.get_name() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; <span class="comment">// prints &quot;p3&quot;</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>The properties are sorted after its order of registration.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of properties. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f2f2e1cb28feb0c7372573423d866ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1property.html">property</a> rttr::type::get_property </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a property with the name <code>name</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there exists no property with the name <code>name</code>, then an invalid property is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A property with name <code>name</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e8ae257da593310bfc4364c48647103"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::get_property_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the property value of property named <code>name</code> from the instance <code>obj</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When the given instance is empty, the value of global property will be tryed to returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A variant containing the value of the property. </dd></dl>

</div>
</div>
<a class="anchor" id="a364b1e09b2808a0bf0b754507f4f8371"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::get_property_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property value of property named <code>name</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A variant containing the value of the property. </dd></dl>

</div>
</div>
<a class="anchor" id="aac824230d873d291293aab2cd176475b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> <a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get_raw_array_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the raw type of an array E.g. for type <code>int[100]</code> it will return the type object of <code>int</code>; <code>const int[10][25]</code> will return also <code>int</code>; etc... </p>
<dl class="section return"><dt>Returns</dt><dd>The raw array type. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7d1f7ba7a387ec15c814963b5b2f7a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> <a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get_raw_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a type object which represent the raw type. A raw type, is a type type without any qualifiers (const and volatile) nor any pointer. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When the current type is already the raw type, it will return an copy from itself.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding raw type object. </dd></dl>

</div>
</div>
<a class="anchor" id="af45f49302f0147f58c15c70f026b0b1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> std::size_t rttr::type::get_sizeof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size in bytes of the object representation of the current type (i.e. <code>sizeof(T)</code>). </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the type in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ab2d32a4853103498bac697e3aeb096"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structrttr_1_1detail_1_1type__converter__base.html">detail::type_converter_base</a> * rttr::type::get_type_converter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>target_type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When for the current type instance a converter function to type <code>target_type</code> was registered, then this function returns a valid pointer to a type_converter_base object. Otherwise this function returns a nullptr. </p>

</div>
</div>
<a class="anchor" id="a43763949ea84a5ebcd11eb98c3aa87cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; rttr::type::get_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range of all registered type objects. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The order of the type object is unspecified.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A range of type objects. </dd></dl>

</div>
</div>
<a class="anchor" id="aead861cbf03c3c0c053bcab465df6f17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> <a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get_wrapped_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a type object which represent the wrapped type. A wrapper type is a class which encapsulate an instance of another type. This encapsulate type is also called <em>wrapped type</em>. </p>
<p>See following example code: </p><div class="fragment"><div class="line"><a class="code" href="classrttr_1_1type.html#ae1a4b3fe8db8012f2feed6f16d9c5fad">type</a> wrapped_type = type::get&lt;std::shared_ptr&lt;int&gt;&gt;().<a class="code" href="classrttr_1_1type.html#aead861cbf03c3c0c053bcab465df6f17">get_wrapped_type</a>();</div>
<div class="line">wrapped_type == type::get&lt;int*&gt;(); <span class="comment">// yields to true</span></div>
<div class="line"></div>
<div class="line">wrapped_type = type::get&lt;std::reference_wrapper&lt;int&gt;&gt;().<a class="code" href="classrttr_1_1type.html#aead861cbf03c3c0c053bcab465df6f17">get_wrapped_type</a>();</div>
<div class="line">wrapped_type == type::get&lt;int&gt;(); <span class="comment">// yields to true</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>When the current type is not a wrapper type, this function will return an <a class="el" href="classrttr_1_1type.html#a369fe02e20b9b98cf22371a55be9ad14">invalid type</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>wrapper_mapper&lt;T&gt;</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The type object of the wrapped type. </dd></dl>

</div>
</div>
<a class="anchor" id="a29dda76c1bd59dacbe1a1281832c7939"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rttr::type::init_globals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize all the global variables needed to retrieve the type informations. </p>

</div>
</div>
<a class="anchor" id="aa9d399ace70b2799d7bb6dab147e09a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#ac7a84ea223b52c78ad7f258ada4ea864">instance()</a>, or as shortcut use simply <code>{}</code>. Methods with registered <a class="el" href="namespacerttr.html#a24de496245cbff4825ee72e482ffac42">default_arguments</a> will be honored.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A variant object containing the possible return value, otherwise when it is a void function an empty but valid variant object. </dd></dl>

</div>
</div>
<a class="anchor" id="a48c98a053d697eb61600db84cac1db2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes a global method named <code>name</code> with the specified argument <code>args</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A variant object containing the possible return value, otherwise when it is a void function an empty but valid variant object. Methods with registered <a class="el" href="namespacerttr.html#a24de496245cbff4825ee72e482ffac42">default_arguments</a> will be honored. </dd></dl>

</div>
</div>
<a class="anchor" id="a4afafd8c51e787e059f77c96287c70f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> bool rttr::type::is_arithmetic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true whether the given type represents an arithmetic type. An arithmetic type is a integral type or a floating point type. e.g. <code>bool</code>, <code>int</code>, <code>float</code>, etc... </p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is a arithmetic type, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="aea5b74552ed9f7f5fa9b716355262b98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> bool rttr::type::is_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true whether the given type represents an array. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is an array, otherwise false.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structrttr_1_1array__mapper.html">array_mapper&lt;T&gt;</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a59c569e3f047cd10996486ae4259db20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> bool rttr::type::is_class </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true whether the given type is class; that is not an atomic type or a method. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is a class, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a83e20a25e9a463afa034d74cebaed0f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> bool rttr::type::is_derived_from </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a36052a3a52eb60314f11e4d613c59d8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_derived_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this type is derived from the given type <code>other</code>, otherwise false. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Make sure that the complete class hierarchy has the macro RTTR_ENABLE inside the class declaration, otherwise the returned information of this function is <b>not correct</b>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this type is a derived type from <code>other</code>, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="ac59b3e5ed8937e7bd6f108fd9a8c866c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_derived_from </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this type is derived from the given type <em>T</em>, otherwise false. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Make sure that the complete class hierarchy has the macro RTTR_ENABLE inside the class declaration, otherwise the returned information of this function is <b>not correct</b>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this type is a derived type from <em>T</em>, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b43b346aec24514269d9cd2d76ddd7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> bool rttr::type::is_enumeration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true whether the given type represents an enumeration. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is an enumeration, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a55a861dee09afdf1f5b287a1cb5e6e16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> bool rttr::type::is_function_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true whether the given type represents a pointer to a function e.g. <code>void (*)(void)</code> </p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is a function pointer, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a134e011a3820e329e6ee06da3f879eeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> bool rttr::type::is_member_function_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true whether the given type represents a pointer to a member function. e.g. <code>void (MyClass::*)(void)</code> </p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is a member function pointer type, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ccb112222ce1d9d3e89c781e358ee5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> bool rttr::type::is_member_object_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true whether the given type represents a pointer to a member object. e.g. <code>int (MyClass::*)</code> </p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is a member object pointer, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="adccddc8b9dc57dffc657ea117b806212"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> bool rttr::type::is_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true whether the given type represents a pointer. e.g. <code>int*</code>, or <code>bool*</code> </p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is a pointer, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a369fe02e20b9b98cf22371a55be9ad14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> bool rttr::type::is_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this type is valid, that means the type holds valid data to a type. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this type is valid, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="af67382543ad029b45c8f8b1fb24bcd18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a3fae648c372260ce628ec8dabae4c83e">RTTR_FORCE_INLINE</a> bool rttr::type::is_wrapper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true whether the given type represents a wrapper type. A wrapper type is a class which encapsulate an instance of another type. RTTR recognize automatically following wrapper types: </p>
<ul>
<li><code><code>std::shared_ptr&lt;T&gt;</code></code> </li>
<li><code><code>std::reference_wrapper&lt;T&gt;</code></code> </li>
<li><code><code>std::weak_ptr&lt;T&gt;</code></code> </li>
<li><code><code>std::unique_ptr&lt;T&gt;</code></code> </li>
</ul>
<p>In order to work with custom wrapper types, its required to specialize the class <a class="el" href="structrttr_1_1wrapper__mapper.html">wrapper_mapper&lt;T&gt;</a> and implement a getter function to retrieve the encapsulate type.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structrttr_1_1wrapper__mapper.html">wrapper_mapper&lt;T&gt;</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the type is an wrapper, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a418976934476eb377fe83fd95138a283"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> rttr::type::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to check if this <a class="el" href="classrttr_1_1type.html">type</a> is valid or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this <a class="el" href="classrttr_1_1type.html">type</a> is valid, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f547bdd0a3202d470b9a93e03568d69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> bool rttr::type::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this type with the <em>other</em> type and returns true if both describe different types, otherwise returns false. </p>
<dl class="section return"><dt>Returns</dt><dd>True if both type are <b>not</b> equal, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f8e40d92359f0ad2b154e91eefbf070"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> bool rttr::type::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator for sorting the type data according to some internal criterion. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this type is less than the <em>other</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="abca10de112732755cf059b80c65a1139"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> bool rttr::type::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator for sorting the type data according to some internal criterion. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this type is less than or equal to <em>other</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9497adb19711d1797d952d5e3525178"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1type.html">type</a> &amp; rttr::type::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a type to another one. </p>
<dl class="section return"><dt>Returns</dt><dd>A type object. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c23c5509bb1230308a36be013f4cc13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> bool rttr::type::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this type with the <em>other</em> type and returns true if both describe the same type, otherwise returns false. </p>
<dl class="section return"><dt>Returns</dt><dd>True if both type are equal, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fb2b7d6d55de3f031d24b5f5b9a2682"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> bool rttr::type::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator for sorting the type data according to some internal criterion. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this type is greater than the <em>other</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="aad4cad0b952ccee31ebc1b95f992377c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> bool rttr::type::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator for sorting the type data according to some internal criterion. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this type is greater than or equal to <em>other</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="adc2c17776d13e346422843aefeb4ccca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rttr::type::register_comparators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register comparison operators for template type <code>T</code>. This requires a valid <code>operator==</code> and <code>operator&lt;</code> for type <code>T</code>. </p>
<p>The registered comparison operators will be used in the <a class="el" href="classrttr_1_1variant.html">variant</a> class.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="comment">// two variants, same content</span></div>
<div class="line"> <a class="code" href="classrttr_1_1type.html#ad4f13d06475a06f860c63bc68d0c8a4b">variant</a> <a class="code" href="variant__cmp__equal__test_8cpp.html#a4124bc0a9335c27f086f24ba207a4912">a</a> = std::make_tuple&lt;int, std::string&gt;(12, std::string(<span class="stringliteral">&quot;some text&quot;</span>));</div>
<div class="line"> <a class="code" href="classrttr_1_1type.html#ad4f13d06475a06f860c63bc68d0c8a4b">variant</a> b = std::make_tuple&lt;int, std::string&gt;(12, std::string(<span class="stringliteral">&quot;some text&quot;</span>));</div>
<div class="line"></div>
<div class="line"> a == <a class="code" href="sw_graphic_a_p_i_2_projects_dir_2_documentation_2html_2jquery_8js.html#aa4026ad5544b958e54ce5e106fa1c805">b</a>;                <span class="comment">// yields to false</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// register comparators for type &#39;std::tuple&lt;std::string, int&gt;&#39;</span></div>
<div class="line"> type::register_comparators&lt;std::tuple&lt;std::string, int&gt;&gt;();</div>
<div class="line"></div>
<div class="line"> a == <a class="code" href="sw_graphic_a_p_i_2_projects_dir_2_documentation_2html_2jquery_8js.html#aa4026ad5544b958e54ce5e106fa1c805">b</a>;                <span class="comment">// yields to true</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a141c446cf462e6eb2a14780a68681fe0" title="Compares this variant with other and returns true if they are equal; otherwise returns false...">variant::operator==()</a>, <a class="el" href="classrttr_1_1variant.html#a6e1e8b31c9853f1bec6f09886cb6df47" title="Compares this variant with other and returns true if this is less than other, otherwise returns false...">variant::operator&lt;()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aee9917f69110374141da3f045ac23247"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> void rttr::type::register_converter_func </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a81f5f2ea31cc79846a829aa5737680f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rttr::type::register_converter_func </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a converter func <code>F</code>, which will be used internally by the <a class="el" href="classrttr_1_1variant.html">variant</a> class to convert between types. </p>
<p>This function converts a <em>source</em> type to a <em>target</em> type. The signature of this function has to be the following: <code>TargetType (SourceType, bool&amp; ok)</code></p>
<p>See following example code: </p><div class="fragment"><div class="line">std::string conv_func(<span class="keywordtype">int</span> <a class="code" href="namespacerttr.html#a405a1d27e1c656f6a81da653d55d180d">value</a>, <span class="keywordtype">bool</span>&amp; <a class="code" href="variant__conv__to__double_8cpp.html#a1d67bd6634a9002df97231d8c8dbc66c">ok</a>)</div>
<div class="line">{</div>
<div class="line">   std::string result = <a class="code" href="namespacerttr_1_1detail.html#af35b755a961eb06d9b3d907846375d66">std::to_string</a>(value);</div>
<div class="line">   ok = <span class="keyword">true</span>;</div>
<div class="line">   <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// register the conversion function</span></div>
<div class="line"><a class="code" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">type::register_converter_func</a>(conv_func);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a48031e0f0a64cc87b7476138071e9c2c" title="Converts the containing variant internally to the given type target_type. When the conversion was suc...">variant::convert()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2a49052ea345144252dd6903bffa267c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type::register_equal_comparator&lt; point &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    <a class="code" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">type::register_converter_func</a>(convert_to_string)</div>
<div class="ttc" id="classrttr_1_1type_html_a81f5f2ea31cc79846a829aa5737680f0"><div class="ttname"><a href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">rttr::type::register_converter_func</a></div><div class="ttdeci">static void register_converter_func(F func)</div><div class="ttdoc">Register a converter func F, which will be used internally by the variant class to convert between ty...</div></div>
</div><!-- fragment -->
<p>Register the equal comparison operators for template type <code>T</code>. This requires a valid <code>operator==</code> for type <code>T</code>. </p>
<p>The registered comparison operators will be used in the <a class="el" href="classrttr_1_1variant.html">variant</a> class.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="comment">// two variants, same content</span></div>
<div class="line"> <a class="code" href="classrttr_1_1type.html#ad4f13d06475a06f860c63bc68d0c8a4b">variant</a> <a class="code" href="variant__cmp__equal__test_8cpp.html#a4124bc0a9335c27f086f24ba207a4912">a</a> = std::make_tuple&lt;int, int&gt;(42, 42);</div>
<div class="line"> <a class="code" href="classrttr_1_1type.html#ad4f13d06475a06f860c63bc68d0c8a4b">variant</a> <a class="code" href="sw_graphic_a_p_i_2_projects_dir_2_documentation_2html_2jquery_8js.html#aa4026ad5544b958e54ce5e106fa1c805">b</a> = std::make_tuple&lt;int, int&gt;(42, 42);</div>
<div class="line"></div>
<div class="line"> a == <a class="code" href="sw_graphic_a_p_i_2_projects_dir_2_documentation_2html_2jquery_8js.html#aa4026ad5544b958e54ce5e106fa1c805">b</a>;                <span class="comment">// yields to false</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// register comparators for type &#39;std::tuple&lt;int, int&gt;&#39;</span></div>
<div class="line"> type::register_comparators&lt;std::tuple&lt;int, int&gt;&gt;();</div>
<div class="line"></div>
<div class="line"> a == <a class="code" href="sw_graphic_a_p_i_2_projects_dir_2_documentation_2html_2jquery_8js.html#aa4026ad5544b958e54ce5e106fa1c805">b</a>;                <span class="comment">// yields to true</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a141c446cf462e6eb2a14780a68681fe0" title="Compares this variant with other and returns true if they are equal; otherwise returns false...">variant::operator==()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aefd1ce4cd4597780446594ff1ae35840"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rttr::type::register_less_than_comparator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register the less than comparison operators for template type <code>T</code>. This requires a valid <code>operator&lt;</code> for type <code>T</code>. </p>
<p>The registered comparison operators will be used in the <a class="el" href="classrttr_1_1variant.html">variant</a> class.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_id</div>
<div class="line">{</div>
<div class="line">   my_id(<span class="keywordtype">int</span> i) : id(i) {}</div>
<div class="line">   <span class="keywordtype">bool</span> <a class="code" href="classrttr_1_1type.html#a9f8e40d92359f0ad2b154e91eefbf070">operator&lt;</a>(<span class="keyword">const</span> foo&amp; rhs)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (<span class="keywordtype">id</span> &lt; rhs.id); }</div>
<div class="line"></div>
<div class="line">   <span class="keywordtype">int</span> id;</div>
<div class="line">};</div>
<div class="line"><span class="comment">// two variants, same content</span></div>
<div class="line"> <a class="code" href="classrttr_1_1type.html#ad4f13d06475a06f860c63bc68d0c8a4b">variant</a> a = my_id(23);</div>
<div class="line"> <a class="code" href="classrttr_1_1type.html#ad4f13d06475a06f860c63bc68d0c8a4b">variant</a> b = my_id(42);</div>
<div class="line"></div>
<div class="line"> a &lt; <a class="code" href="sw_graphic_a_p_i_2_projects_dir_2_documentation_2html_2jquery_8js.html#aa4026ad5544b958e54ce5e106fa1c805">b</a>;                <span class="comment">// yields to false</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// register comparators for type &#39;my_id&#39;</span></div>
<div class="line"> type::register_less_than_comparator&lt;my_id&gt;();</div>
<div class="line"></div>
<div class="line"> a &lt; <a class="code" href="sw_graphic_a_p_i_2_projects_dir_2_documentation_2html_2jquery_8js.html#aa4026ad5544b958e54ce5e106fa1c805">b</a>;                <span class="comment">// yields to true</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a6e1e8b31c9853f1bec6f09886cb6df47" title="Compares this variant with other and returns true if this is less than other, otherwise returns false...">variant::operator&lt;()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4348f6d732721f82cff442f2c0b64d40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::set_property_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will set the given value <code>arg</code> to a property named <code>name</code> to the instance <code>obj</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When the given instance is empty, the value of a global property with name <code>name</code> will be tryed to set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A bool value, which is true, when the value could be set, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="af1a1c5cadec4686935e4ac6ea11ea2e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::set_property_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerttr.html#a61265f69675ac438ecfa23b084adaa56">string_view</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function will set the given value <code>arg</code> to a property named <code>name</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A bool value, which is true, when the value could be set, otherwise false. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a6e95db5d7eb2176229cdd6cd5d7e9a95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1type.html">type</a> detail::get_invalid_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac23d84cbf46a62ef9615e256230aafd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrttr_1_1detail_1_1type__data.html">detail::type_data</a>&amp; <a class="el" href="namespacerttr_1_1detail.html#a7e920271107921e81368bb4dbf708be3">detail::get_type_data</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0b46cb31e07e852c62c550f358671b0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Enable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structrttr_1_1detail_1_1type__getter.html">detail::type_getter</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aac397ff81d3c07fd5c1711b3b37a95ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classrttr_1_1detail_1_1type__register.html">detail::type_register</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab5983fa63738d32e629a0055af54da47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classrttr_1_1detail_1_1type__register__private.html">detail::type_register_private</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4be882f1f7adb23031cabee74d6d1699"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classrttr_1_1instance.html">instance</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a786039d5bfd109c54b9b375809b6da80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Target_Type , typename Source_Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Target_Type rttr_cast </td>
          <td>(</td>
          <td class="paramtype">Source_Type&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the given <code>object</code> of type <code>Source_Type</code> to an object of type <code>Target_Type</code>. </p>
<p>When the given the given <code>object</code> is an instance of type <code>Target_Type</code>, then this function will cast the pointer to the <code>TargetType</code>; otherwise it will return a <code>nullptr</code>. If <code>object</code> is already a <code>nullptr</code> then it will also return a <code>nullptr</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Both class types must contain the macro <a class="el" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a> in the class declaration. <code>Source_Type</code> and <code>Target_Type</code> must be both pointer types.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer of type <code>Target_Type</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ad4f13d06475a06f860c63bc68d0c8a4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classrttr_1_1variant.html">variant</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a8cad87fef71ec4fa4dfc1d274d6b53dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrttr_1_1detail_1_1type__data.html">detail::type_data</a>* rttr::type::m_type_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/ProgramyVS/SWLibraries/swCommonLib/Reflection/src/rttr/<a class="el" href="type_8h_source.html">type.h</a></li>
<li>D:/ProgramyVS/SWLibraries/swCommonLib/Reflection/src/rttr/detail/type/<a class="el" href="type__impl_8h_source.html">type_impl.h</a></li>
<li>D:/ProgramyVS/SWLibraries/swCommonLib/Reflection/src/rttr/<a class="el" href="type_8cpp.html">type.cpp</a></li>
<li>D:/ProgramyVS/SWLibraries/swCommonLib/Reflection/src/unit_tests/variant/<a class="el" href="variant__cmp__equal__test_8cpp.html">variant_cmp_equal_test.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 9 2017 14:01:28 for Sleeping Wombat GUI by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
