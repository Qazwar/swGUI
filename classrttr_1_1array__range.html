<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Sleeping Wombat GUI: rttr::array_range&lt; T, Predicate &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Sleeping Wombat GUI
   &#160;<span id="projectnumber">0.100</span>
   </div>
   <div id="projectbrief">swGUI</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerttr.html">rttr</a></li><li class="navelem"><a class="el" href="classrttr_1_1array__range.html">array_range</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classrttr_1_1array__range-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rttr::array_range&lt; T, Predicate &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="array__range_8h_source.html">array_range.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range_1_1array__iterator.html">array_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range_1_1array__iterator__base.html">array_iterator_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range_1_1array__reverse__iterator.html">array_reverse_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a568cdf1e55c4686cc9fc31bc9bdccc6a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a568cdf1e55c4686cc9fc31bc9bdccc6a">value_type</a> = T</td></tr>
<tr class="separator:a568cdf1e55c4686cc9fc31bc9bdccc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea3dc42cccc2e26cb9ee8fa6fd1d534"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a7ea3dc42cccc2e26cb9ee8fa6fd1d534">bounds_type</a> = T *</td></tr>
<tr class="separator:a7ea3dc42cccc2e26cb9ee8fa6fd1d534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc99768a20e004e8bb2c2dd8f6f38e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#aedc99768a20e004e8bb2c2dd8f6f38e5">size_type</a> = std::size_t</td></tr>
<tr class="separator:aedc99768a20e004e8bb2c2dd8f6f38e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0258d2c5cec42693d3c3d5583f03bf3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#ac0258d2c5cec42693d3c3d5583f03bf3">iterator</a> = <a class="el" href="classrttr_1_1array__range_1_1array__iterator.html">array_iterator</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ac0258d2c5cec42693d3c3d5583f03bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator.  <a href="#ac0258d2c5cec42693d3c3d5583f03bf3">More...</a><br /></td></tr>
<tr class="separator:ac0258d2c5cec42693d3c3d5583f03bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cd5ffa9de2d2fca76d486cf0461976"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a> = <a class="el" href="classrttr_1_1array__range_1_1array__iterator.html">array_iterator</a>&lt; const T &gt;</td></tr>
<tr class="memdesc:a62cd5ffa9de2d2fca76d486cf0461976"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant forward iterator.  <a href="#a62cd5ffa9de2d2fca76d486cf0461976">More...</a><br /></td></tr>
<tr class="separator:a62cd5ffa9de2d2fca76d486cf0461976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4d75a6ecd9a31c8e7cffbed51d1938"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#afc4d75a6ecd9a31c8e7cffbed51d1938">reverse_iterator</a> = <a class="el" href="classrttr_1_1array__range_1_1array__reverse__iterator.html">array_reverse_iterator</a>&lt; T &gt;</td></tr>
<tr class="memdesc:afc4d75a6ecd9a31c8e7cffbed51d1938"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator that reverses the direction.  <a href="#afc4d75a6ecd9a31c8e7cffbed51d1938">More...</a><br /></td></tr>
<tr class="separator:afc4d75a6ecd9a31c8e7cffbed51d1938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa344d1585997aed6c09623b16cc7539"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a> = <a class="el" href="classrttr_1_1array__range_1_1array__reverse__iterator.html">array_reverse_iterator</a>&lt; const T &gt;</td></tr>
<tr class="memdesc:aaa344d1585997aed6c09623b16cc7539"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant forward iterator that reverses the direction.  <a href="#aaa344d1585997aed6c09623b16cc7539">More...</a><br /></td></tr>
<tr class="separator:aaa344d1585997aed6c09623b16cc7539"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a810d34ea989dbb540853887bd1ef0563"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a810d34ea989dbb540853887bd1ef0563">array_range</a> ()</td></tr>
<tr class="memdesc:a810d34ea989dbb540853887bd1ef0563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Constructs an empty <a class="el" href="classrttr_1_1array__range.html">array_range</a>.  <a href="#a810d34ea989dbb540853887bd1ef0563">More...</a><br /></td></tr>
<tr class="separator:a810d34ea989dbb540853887bd1ef0563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8abecbd4970d162ef24b76dc143217f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#ac8abecbd4970d162ef24b76dc143217f">array_range</a> (const T *<a class="el" href="classrttr_1_1array__range.html#a56c56737eba927a080a3aae962aa84a8">begin</a>, <a class="el" href="classrttr_1_1array__range.html#aedc99768a20e004e8bb2c2dd8f6f38e5">size_type</a> <a class="el" href="classrttr_1_1array__range.html#a6831960dc3c4e27231468368a37472de">size</a>, const Predicate &amp;pred=Predicate())</td></tr>
<tr class="memdesc:ac8abecbd4970d162ef24b76dc143217f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an array range starting from <code>begin</code> to <code>end</code> [begin, end).  <a href="#ac8abecbd4970d162ef24b76dc143217f">More...</a><br /></td></tr>
<tr class="separator:ac8abecbd4970d162ef24b76dc143217f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c56737eba927a080a3aae962aa84a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a56c56737eba927a080a3aae962aa84a8">begin</a> ()</td></tr>
<tr class="memdesc:a56c56737eba927a080a3aae962aa84a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the range.  <a href="#a56c56737eba927a080a3aae962aa84a8">More...</a><br /></td></tr>
<tr class="separator:a56c56737eba927a080a3aae962aa84a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4875b3d9cc14b5c111b3fa455deb0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a7b4875b3d9cc14b5c111b3fa455deb0e">end</a> ()</td></tr>
<tr class="memdesc:a7b4875b3d9cc14b5c111b3fa455deb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the range.  <a href="#a7b4875b3d9cc14b5c111b3fa455deb0e">More...</a><br /></td></tr>
<tr class="separator:a7b4875b3d9cc14b5c111b3fa455deb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2f9e32286b5b9dfd950d58a6d535f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#add2f9e32286b5b9dfd950d58a6d535f6">begin</a> () const </td></tr>
<tr class="memdesc:add2f9e32286b5b9dfd950d58a6d535f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the first element of the range.  <a href="#add2f9e32286b5b9dfd950d58a6d535f6">More...</a><br /></td></tr>
<tr class="separator:add2f9e32286b5b9dfd950d58a6d535f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd8ebc1472c2a7d9cce021fe877deff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#affd8ebc1472c2a7d9cce021fe877deff">end</a> () const </td></tr>
<tr class="memdesc:affd8ebc1472c2a7d9cce021fe877deff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the element following the last element of the range.  <a href="#affd8ebc1472c2a7d9cce021fe877deff">More...</a><br /></td></tr>
<tr class="separator:affd8ebc1472c2a7d9cce021fe877deff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9df7108abb92055e142451626c8e755"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#ab9df7108abb92055e142451626c8e755">cbegin</a> () const </td></tr>
<tr class="memdesc:ab9df7108abb92055e142451626c8e755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the first element of the range.  <a href="#ab9df7108abb92055e142451626c8e755">More...</a><br /></td></tr>
<tr class="separator:ab9df7108abb92055e142451626c8e755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0752fe1c33401bec9ac27e80d624766f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a0752fe1c33401bec9ac27e80d624766f">cend</a> () const </td></tr>
<tr class="memdesc:a0752fe1c33401bec9ac27e80d624766f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the element following the last element of the range.  <a href="#a0752fe1c33401bec9ac27e80d624766f">More...</a><br /></td></tr>
<tr class="separator:a0752fe1c33401bec9ac27e80d624766f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da4d124a895f36083949f4883bdf340"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a9da4d124a895f36083949f4883bdf340">rbegin</a> ()</td></tr>
<tr class="memdesc:a9da4d124a895f36083949f4883bdf340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed range. It corresponds to the last element of the non-reversed range.  <a href="#a9da4d124a895f36083949f4883bdf340">More...</a><br /></td></tr>
<tr class="separator:a9da4d124a895f36083949f4883bdf340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc4579163e9de0d3db1044a31f1b63a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a2cc4579163e9de0d3db1044a31f1b63a">rend</a> ()</td></tr>
<tr class="memdesc:a2cc4579163e9de0d3db1044a31f1b63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed range. It corresponds to the element preceding the first element of the non-reversed range.  <a href="#a2cc4579163e9de0d3db1044a31f1b63a">More...</a><br /></td></tr>
<tr class="separator:a2cc4579163e9de0d3db1044a31f1b63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ca68d1d814eab523deeafdeee291fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a97ca68d1d814eab523deeafdeee291fd">rbegin</a> () const </td></tr>
<tr class="memdesc:a97ca68d1d814eab523deeafdeee291fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator to the first element of the reversed range. It corresponds to the last element of the non-reversed range.  <a href="#a97ca68d1d814eab523deeafdeee291fd">More...</a><br /></td></tr>
<tr class="separator:a97ca68d1d814eab523deeafdeee291fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a26c7ee3bedae90c53fc4ab797a1a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a10a26c7ee3bedae90c53fc4ab797a1a6">rend</a> () const </td></tr>
<tr class="memdesc:a10a26c7ee3bedae90c53fc4ab797a1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator to the element following the last element of the reversed range. It corresponds to the element preceding the first element of the non-reversed range.  <a href="#a10a26c7ee3bedae90c53fc4ab797a1a6">More...</a><br /></td></tr>
<tr class="separator:a10a26c7ee3bedae90c53fc4ab797a1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5044f3df7540aa4a6858ad7c44a38898"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a5044f3df7540aa4a6858ad7c44a38898">crbegin</a> () const </td></tr>
<tr class="memdesc:a5044f3df7540aa4a6858ad7c44a38898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator to the first element of the reversed range. It corresponds to the last element of the non-reversed range.  <a href="#a5044f3df7540aa4a6858ad7c44a38898">More...</a><br /></td></tr>
<tr class="separator:a5044f3df7540aa4a6858ad7c44a38898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d3df4cdcba7142b9d76b7d1b07cc3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#aa3d3df4cdcba7142b9d76b7d1b07cc3e">crend</a> () const </td></tr>
<tr class="memdesc:aa3d3df4cdcba7142b9d76b7d1b07cc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator to the element following the last element of the reversed range. It corresponds to the element preceding the first element of the non-reversed range.  <a href="#aa3d3df4cdcba7142b9d76b7d1b07cc3e">More...</a><br /></td></tr>
<tr class="separator:aa3d3df4cdcba7142b9d76b7d1b07cc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6831960dc3c4e27231468368a37472de"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a6831960dc3c4e27231468368a37472de">size</a> () const </td></tr>
<tr class="memdesc:a6831960dc3c4e27231468368a37472de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the range.  <a href="#a6831960dc3c4e27231468368a37472de">More...</a><br /></td></tr>
<tr class="separator:a6831960dc3c4e27231468368a37472de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4abf269868039d123debe0413fd93b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#ab4abf269868039d123debe0413fd93b9">empty</a> () const </td></tr>
<tr class="memdesc:ab4abf269868039d123debe0413fd93b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the range has no elements, i.e. whether <code><a class="el" href="classrttr_1_1array__range.html#a56c56737eba927a080a3aae962aa84a8" title="Returns an iterator to the first element of the range. ">begin()</a> == <a class="el" href="classrttr_1_1array__range.html#a7b4875b3d9cc14b5c111b3fa455deb0e" title="Returns an iterator to the element following the last element of the range. ">end()</a></code>.  <a href="#ab4abf269868039d123debe0413fd93b9">More...</a><br /></td></tr>
<tr class="separator:ab4abf269868039d123debe0413fd93b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c0502d0733c5dd3be944d792a08606"><td class="memTemplParams" colspan="2">template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:a19c0502d0733c5dd3be944d792a08606"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a19c0502d0733c5dd3be944d792a08606">next</a> (<a class="el" href="classrttr_1_1array__range_1_1array__iterator.html">array_iterator</a>&lt; DataType &gt; &amp;<a class="el" href="array__range__test_8cpp.html#a290c951c7266f15d671f7ce4c470992f">itr</a>) const </td></tr>
<tr class="separator:a19c0502d0733c5dd3be944d792a08606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc79ba6edd630c839bb5e3d39b22b8f"><td class="memTemplParams" colspan="2">template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:a4fc79ba6edd630c839bb5e3d39b22b8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a4fc79ba6edd630c839bb5e3d39b22b8f">prev</a> (<a class="el" href="classrttr_1_1array__range_1_1array__reverse__iterator.html">array_reverse_iterator</a>&lt; DataType &gt; &amp;<a class="el" href="array__range__test_8cpp.html#a290c951c7266f15d671f7ce4c470992f">itr</a>) const </td></tr>
<tr class="separator:a4fc79ba6edd630c839bb5e3d39b22b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad9bedb039c0071e3ddad9c53753821b4"><td class="memTemplParams" colspan="2">template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:ad9bedb039c0071e3ddad9c53753821b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#ad9bedb039c0071e3ddad9c53753821b4">next</a> (<a class="el" href="classrttr_1_1array__range_1_1array__iterator.html">array_iterator</a>&lt; DataType &gt; &amp;<a class="el" href="array__range__test_8cpp.html#a290c951c7266f15d671f7ce4c470992f">itr</a>) const </td></tr>
<tr class="separator:ad9bedb039c0071e3ddad9c53753821b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d0aa14b3fa5be81722ceb3f21e832e"><td class="memTemplParams" colspan="2">template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:ac1d0aa14b3fa5be81722ceb3f21e832e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#ac1d0aa14b3fa5be81722ceb3f21e832e">prev</a> (<a class="el" href="classrttr_1_1array__range_1_1array__reverse__iterator.html">array_reverse_iterator</a>&lt; DataType &gt; &amp;<a class="el" href="array__range__test_8cpp.html#a290c951c7266f15d671f7ce4c470992f">itr</a>) const </td></tr>
<tr class="separator:ac1d0aa14b3fa5be81722ceb3f21e832e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfa11b227c342c882af457fc49063e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a1dfa11b227c342c882af457fc49063e7">empty_</a> () const </td></tr>
<tr class="separator:a1dfa11b227c342c882af457fc49063e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a63fa9f0bc91852aa07b060b4dcf405bd"><td class="memItemLeft" align="right" valign="top">const T *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a63fa9f0bc91852aa07b060b4dcf405bd">m_begin</a></td></tr>
<tr class="separator:a63fa9f0bc91852aa07b060b4dcf405bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1131b0f007a144526b164426bbf99d"><td class="memItemLeft" align="right" valign="top">const T *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#add1131b0f007a144526b164426bbf99d">m_end</a></td></tr>
<tr class="separator:add1131b0f007a144526b164426bbf99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd1e606afc11311721a27ac166c1e12"><td class="memItemLeft" align="right" valign="top">const Predicate&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1array__range.html#a4bd1e606afc11311721a27ac166c1e12">m_pred</a></td></tr>
<tr class="separator:a4bd1e606afc11311721a27ac166c1e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Predicate = detail::default_predicate&lt;T&gt;&gt;<br />
class rttr::array_range&lt; T, Predicate &gt;</h3>

<p>The <a class="el" href="classrttr_1_1array__range.html">array_range</a> class provides a view into an underlying data structure with lower and upper limits. In order to iterate over the data structure use the returned forward iterators from <a class="el" href="classrttr_1_1array__range.html#a56c56737eba927a080a3aae962aa84a8" title="Returns an iterator to the first element of the range. ">begin()</a> or <a class="el" href="classrttr_1_1array__range.html#a9da4d124a895f36083949f4883bdf340" title="Returns a reverse iterator to the first element of the reversed range. It corresponds to the last ele...">rbegin()</a>. To check whether the end of the range has reached use <a class="el" href="classrttr_1_1array__range.html#a7b4875b3d9cc14b5c111b3fa455deb0e" title="Returns an iterator to the element following the last element of the range. ">end()</a> or <a class="el" href="classrttr_1_1array__range.html#a2cc4579163e9de0d3db1044a31f1b63a" title="Returns a reverse iterator to the element following the last element of the reversed range...">rend()</a>. Using the standard C++ range-based for loop will implicit do all this work.</p>
<dl class="section remark"><dt>Remarks</dt><dd>When the underlying data structure gets modified while holding a range, its iterators and the range itself will be invalidated. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a7ea3dc42cccc2e26cb9ee8fa6fd1d534"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Predicate = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#a7ea3dc42cccc2e26cb9ee8fa6fd1d534">bounds_type</a> =  T*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a62cd5ffa9de2d2fca76d486cf0461976"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Predicate = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a> =  <a class="el" href="classrttr_1_1array__range_1_1array__iterator.html">array_iterator</a>&lt;const T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constant forward iterator. </p>

</div>
</div>
<a class="anchor" id="aaa344d1585997aed6c09623b16cc7539"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Predicate = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a> =  <a class="el" href="classrttr_1_1array__range_1_1array__reverse__iterator.html">array_reverse_iterator</a>&lt;const T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constant forward iterator that reverses the direction. </p>

</div>
</div>
<a class="anchor" id="ac0258d2c5cec42693d3c3d5583f03bf3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Predicate = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#ac0258d2c5cec42693d3c3d5583f03bf3">iterator</a> =  <a class="el" href="classrttr_1_1array__range_1_1array__iterator.html">array_iterator</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A forward iterator. </p>

</div>
</div>
<a class="anchor" id="afc4d75a6ecd9a31c8e7cffbed51d1938"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Predicate = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#afc4d75a6ecd9a31c8e7cffbed51d1938">reverse_iterator</a> =  <a class="el" href="classrttr_1_1array__range_1_1array__reverse__iterator.html">array_reverse_iterator</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A forward iterator that reverses the direction. </p>

</div>
</div>
<a class="anchor" id="aedc99768a20e004e8bb2c2dd8f6f38e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Predicate = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#aedc99768a20e004e8bb2c2dd8f6f38e5">size_type</a> =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a568cdf1e55c4686cc9fc31bc9bdccc6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Predicate = detail::default_predicate&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#a568cdf1e55c4686cc9fc31bc9bdccc6a">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a810d34ea989dbb540853887bd1ef0563"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html">array_range</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. Constructs an empty <a class="el" href="classrttr_1_1array__range.html">array_range</a>. </p>

</div>
</div>
<a class="anchor" id="ac8abecbd4970d162ef24b76dc143217f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html">array_range</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1array__range.html#aedc99768a20e004e8bb2c2dd8f6f38e5">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>Predicate()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an array range starting from <code>begin</code> to <code>end</code> [begin, end). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Marks the start of the range. Is included of the range. </td></tr>
    <tr><td class="paramname">size</td><td>The number of elements to include in the range. </td></tr>
    <tr><td class="paramname">pred</td><td>Determines whether an element in the range fulfills the condition of the predicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a56c56737eba927a080a3aae962aa84a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a7b4875b3d9cc14b5c111b3fa455deb0e">end()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="add2f9e32286b5b9dfd950d58a6d535f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator to the first element of the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a7b4875b3d9cc14b5c111b3fa455deb0e">end()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator to the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9df7108abb92055e142451626c8e755"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator to the first element of the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a7b4875b3d9cc14b5c111b3fa455deb0e">end()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator to the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="a0752fe1c33401bec9ac27e80d624766f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator to the element following the last element of the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This element acts as placeholder, attempting to access it results in <b>undefined behavior</b>. If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a56c56737eba927a080a3aae962aa84a8">begin()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator to the element following the last element. </dd></dl>

</div>
</div>
<a class="anchor" id="a5044f3df7540aa4a6858ad7c44a38898"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator to the first element of the reversed range. It corresponds to the last element of the non-reversed range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a2cc4579163e9de0d3db1044a31f1b63a">rend()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Constant reverse iterator to the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3d3df4cdcba7142b9d76b7d1b07cc3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator to the element following the last element of the reversed range. It corresponds to the element preceding the first element of the non-reversed range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a9da4d124a895f36083949f4883bdf340">rbegin()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Constant reverse iterator to the element following the last element. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4abf269868039d123debe0413fd93b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> bool <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the range has no elements, i.e. whether <code><a class="el" href="classrttr_1_1array__range.html#a56c56737eba927a080a3aae962aa84a8" title="Returns an iterator to the first element of the range. ">begin()</a> == <a class="el" href="classrttr_1_1array__range.html#a7b4875b3d9cc14b5c111b3fa455deb0e" title="Returns an iterator to the element following the last element of the range. ">end()</a></code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Every element will be checked against the condition of the used predicate. Only when every element doe not fulfill the condition of predicate, the range is declared empty. That means, in order to check for emptiness, the underlying algorithm needs to iterate through the whole range. So don't call it to often. It's better to cache the result in a temporary variable.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if this range is empty, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1dfa11b227c342c882af457fc49063e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> bool <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::empty_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b4875b3d9cc14b5c111b3fa455deb0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This element acts as placeholder, attempting to access it results in <b>undefined behavior</b>. If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a56c56737eba927a080a3aae962aa84a8">begin()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a class="anchor" id="affd8ebc1472c2a7d9cce021fe877deff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#a62cd5ffa9de2d2fca76d486cf0461976">const_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator to the element following the last element of the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This element acts as placeholder, attempting to access it results in <b>undefined behavior</b>. If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a56c56737eba927a080a3aae962aa84a8">begin()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator to the element following the last element. </dd></dl>

</div>
</div>
<a class="anchor" id="a19c0502d0733c5dd3be944d792a08606"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Predicate = detail::default_predicate&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> void <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1array__range_1_1array__iterator.html">array_iterator</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>itr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad9bedb039c0071e3ddad9c53753821b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Predicate = detail::default_predicate&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1array__range_1_1array__iterator.html">array_iterator</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>itr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4fc79ba6edd630c839bb5e3d39b22b8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Predicate = detail::default_predicate&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> void <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1array__range_1_1array__reverse__iterator.html">array_reverse_iterator</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>itr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac1d0aa14b3fa5be81722ceb3f21e832e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Predicate = detail::default_predicate&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1array__range_1_1array__reverse__iterator.html">array_reverse_iterator</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>itr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9da4d124a895f36083949f4883bdf340"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed range. It corresponds to the last element of the non-reversed range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a2cc4579163e9de0d3db1044a31f1b63a">rend()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="a97ca68d1d814eab523deeafdeee291fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator to the first element of the reversed range. It corresponds to the last element of the non-reversed range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a2cc4579163e9de0d3db1044a31f1b63a">rend()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Constant reverse iterator to the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cc4579163e9de0d3db1044a31f1b63a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed range. It corresponds to the element preceding the first element of the non-reversed range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a9da4d124a895f36083949f4883bdf340">rbegin()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

</div>
</div>
<a class="anchor" id="a10a26c7ee3bedae90c53fc4ab797a1a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> <a class="el" href="classrttr_1_1array__range.html">array_range</a>&lt; T, Predicate &gt;::<a class="el" href="classrttr_1_1array__range.html#aaa344d1585997aed6c09623b16cc7539">const_reverse_iterator</a> <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator to the element following the last element of the reversed range. It corresponds to the element preceding the first element of the non-reversed range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the range is empty, the returned iterator will be equal to <a class="el" href="classrttr_1_1array__range.html#a9da4d124a895f36083949f4883bdf340">rbegin()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Constant reverse iterator to the element following the last element. </dd></dl>

</div>
</div>
<a class="anchor" id="a6831960dc3c4e27231468368a37472de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core__prerequisites_8h.html#a0205dc31a6716f8981bc80776e20246e">RTTR_INLINE</a> size_t <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements in the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Every element will be checked against the condition of the used predicate. Only elements which fulfill the condition of predicate will be included in the counter. That means, in order to determine the size of the range, the underlying algorithm needs to iterate through the whole range. So don't call it to often. It's better to cache the result in a temporary variable.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the range. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a63fa9f0bc91852aa07b060b4dcf405bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Predicate = detail::default_predicate&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* const <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::m_begin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="add1131b0f007a144526b164426bbf99d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Predicate = detail::default_predicate&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* const <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::m_end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4bd1e606afc11311721a27ac166c1e12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Predicate = detail::default_predicate&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Predicate <a class="el" href="classrttr_1_1array__range.html">rttr::array_range</a>&lt; T, Predicate &gt;::m_pred</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/ProgramyVS/SWLibraries/swCommonLib/Reflection/src/rttr/<a class="el" href="array__range_8h_source.html">array_range.h</a></li>
<li>D:/ProgramyVS/SWLibraries/swCommonLib/Reflection/src/rttr/detail/impl/<a class="el" href="array__range__impl_8h_source.html">array_range_impl.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 9 2017 14:01:28 for Sleeping Wombat GUI by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
